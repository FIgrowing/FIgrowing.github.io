<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MVCC机制及其原理</title>
    <url>/2023/55c34784.html</url>
    <content><![CDATA[<p>helllo！大家好，今天主要给大家分享一篇有关MySQL中可重复读隔离级别的实现原理，废话不多说，我们直接进入正题！</p>
<h1 id="四大隔离级别与MVCC机制"><a href="#四大隔离级别与MVCC机制" class="headerlink" title="四大隔离级别与MVCC机制"></a>四大隔离级别与MVCC机制</h1><p>在介绍可重复读的实现原理之前我们有必要先来了解一下四大隔离级别与MVCC机制的实现原理</p>
<h2 id="一-四大隔离级别"><a href="#一-四大隔离级别" class="headerlink" title="一.四大隔离级别"></a>一.四大隔离级别</h2><ul>
<li><font color="red">READ UNCOMMITTED</font>:读未提交，在该隔离级别下，所有事务都可以看到其他事务未提交的数据。不能避免脏读，不可重复读和幻读。</li>
<li><font color="red">READ COMMITTED</font>:读已提交，在该隔离级别下，一个事务只能看见其他事务已经提交的改变。可以避免脏读，但是依然存在不可重复读和幻读问题。</li>
<li><font color="red">REPEATABLE READ</font>:可重复读，当一个事务正在读取数据时，其他事务对该数据的修改对当前事务是不可见的。解决了不可重复读，也是MySQL的默认隔离级别，但依旧存在幻读问题。</li>
<li><font color="red">SERIALIZABLE</font>:可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读</li>
</ul>
<h2 id="二-MVCC"><a href="#二-MVCC" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><h3 id="什么是MVCC机制呢？"><a href="#什么是MVCC机制呢？" class="headerlink" title="什么是MVCC机制呢？"></a>什么是MVCC机制呢？</h3><p>MVCC （Multiversion Concurrency Control），即多版本并发控制。顾名思义，是通过数据行的多个版本管理来实现数据库的并发控制。讲人话就是，每个事务都是在对数据行不同的版本进行操作，实现了数据一致性读的。</p>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><h4 id="1-隐藏字段和Undo-Log版本链"><a href="#1-隐藏字段和Undo-Log版本链" class="headerlink" title="1.隐藏字段和Undo Log版本链"></a>1.隐藏字段和Undo Log版本链</h4><p>对InnoDB数据存储结构了解的朋友来说，想必对于trx_id和roll-pointer这两条隐藏列应该不陌生，这里再做一下解释</p>
<ul>
<li><p><strong>trx-id</strong>:每次对某一条聚簇索引改动时都会把该事务的id赋值给trx_id</p>
</li>
<li><p><strong>roll-pointer</strong>:每次对聚簇索引进行改变时，都会把旧版本写入undo日志中，而roll_pointer类似一个指针指向修改之前的那个旧版本，这样就可以通过该隐藏列修改之前的数据</p>
<p><img src="/../images/1-1.png"></p>
<p><strong>假如有两条id分别为10，20的事务对该条数据进行update操作</strong></p>
<table>
<thead>
<tr>
<th align="left">顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td align="left">2</td>
<td></td>
<td>begin</td>
</tr>
<tr>
<td align="left">3</td>
<td>update set name&#x3D;”李四” where id &#x3D;1;</td>
<td></td>
</tr>
<tr>
<td align="left">4</td>
<td>update set name&#x3D;”王五” where id &#x3D;1;</td>
<td></td>
</tr>
<tr>
<td align="left">5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td align="left">6</td>
<td></td>
<td>update set name&#x3D;”钱七” where id &#x3D;1;</td>
</tr>
<tr>
<td align="left">7</td>
<td></td>
<td>update set name&#x3D;”宋八” where id &#x3D;1;</td>
</tr>
<tr>
<td align="left">8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<hr>
</li>
</ul>
<p><strong><font color="brown">其对应的undolog版本链如下：</font></strong></p>
<p><img src="/../images/1-2.png"></p>
<h4 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2.ReadView"></a>2.ReadView</h4><h6 id="2-1-什么是ReadView？为什么要引入ReadView？"><a href="#2-1-什么是ReadView？为什么要引入ReadView？" class="headerlink" title="2.1 什么是ReadView？为什么要引入ReadView？"></a>2.1 什么是ReadView？为什么要引入ReadView？</h6><p>ReadView其实就是一个事务开启时对某条记录进行操作时生成的版本快照。</p>
<ul>
<li>使用 READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</li>
<li>使用 SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</li>
<li>使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。</li>
</ul>
<p><strong>核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</strong></p>
<h6 id="2-2-ReadView的主要组成部分"><a href="#2-2-ReadView的主要组成部分" class="headerlink" title="2.2 ReadView的主要组成部分"></a>2.2 ReadView的主要组成部分</h6><ul>
<li><strong>creator-trx-id</strong>:创建这个 Read View 的事务 ID。</li>
<li><strong>trx-ids</strong>:表示当前系统中活跃的事务的id列表</li>
<li><strong>min-trx-id</strong>:表示当前活跃事务列表中最小的事务id</li>
<li><strong>max-trx-id</strong>:表示生成ReadView时系统中应该分配给下一个事务的 id 值（这里需要注意的是，max-trx-id是指的系统中的最大事务id之后应该分配的id，有别于最大活跃事务id）</li>
</ul>
<h5 id="2-3-ReadView的应用规则"><a href="#2-3-ReadView的应用规则" class="headerlink" title="2.3 ReadView的应用规则"></a>2.3 ReadView的应用规则</h5><p>有了这个ReadView就可以根据以下规则判断当前版本信息是否可见</p>
<ul>
<li><p>如果当前被访问版本的trx_id与当前ReadView的creator-trx-id相同，那就意味着当前事务正在访问它之前修改过的数据，所以该版本的数据对于当前事务来说是可见的</p>
</li>
<li><p>如果当前被访问版本的trx_id小于ReadView中的min-trx-id:，那就意味着生成该ReadView版本的事务在当前版本生成ReadView之前就已经提交了，所以该条记录对于当前事务来说是可见的</p>
</li>
<li><p>如果当前被访问版本的trx_id大于或等于max-trx-id:，那就意味着生成该版本的事务是在当前版本生成ReadView之后才开启的，所以版本数据对于当前事务来说是不可见的</p>
</li>
<li><p>如果当前被访问版本的ReadView的trx_id在min-trx-id和max-trx-id之间的话，那就要判断一下trx_id在不在trx_ids列表中，此时存在两种情况</p>
<p><em><strong>第一种情况：</strong></em> ReadView的trx_id<strong>在</strong>min-trx-id和max-trx-id之间，那么生成该版本的事务还未提交，因此，对于当前事务来说该版本的记录是不可见的 </p>
<p><em><strong>第二种情况：</strong></em> ReadView的trx_id<strong>不在</strong>min-trx-id和max-trx-id之间，那么就意味着生成该ReadView版本的事务已经提交，该版本的记录对于当前事务来说是可见的</p>
</li>
</ul>
<h5 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h5><p>不知道看到这里的朋友有没有思考过这样一个问题，如下：<br>现在有两个活跃的事务A,B他们的id分别是10和20，当A查询了某条记录后，B对该记录做了修改，并且B提交了事务，<br>此时，该记录的ReadView的trx_id应该为20，此时A事务再去对该记录进行查询操作，这时候A会发现这条记录的ReadView为20既比自己的10大，又比max_trx_id（21）小，且不在trx_ids里面，根据上面提到的ReadView应用规则，A事务是可以去读取这条记录的，那这不违反了可重复读的隔离机制了吗？别急，接下来我们就来讲讲MVCC机制是如何来实现隔离级别的。</p>
<h2 id="三-MVCC机制如何保证隔离级别的实现"><a href="#三-MVCC机制如何保证隔离级别的实现" class="headerlink" title="三.MVCC机制如何保证隔离级别的实现"></a>三.MVCC机制如何保证隔离级别的实现</h2><p>想必能看到这里的朋友们对MVCC的原理已经有了基本的了解，那么接下来我们就来看看MVCC机制如何保证隔离级别的实现，由于READ UNCOMMITTED 隔离级别的事务是当前读，SERIALIZABLE 隔离级别的事务是基于锁实现的，所以，我们在这里主要讨论<strong>读已提交和可重复读</strong>。</p>
<h3 id="3-1-MVCC的整体操作流程"><a href="#3-1-MVCC的整体操作流程" class="headerlink" title="3.1 MVCC的整体操作流程"></a>3.1 MVCC的整体操作流程</h3><ol>
<li>首先获取事务自己的版本号，也就是事务id</li>
<li>然后获取ReadView</li>
<li>将自己的事务id与ReadView的trx_id进行比较</li>
<li>如果不符合ReadView的规则，那么就从Undo Log中获取历史快照</li>
<li>最后返回符合规则的数据</li>
</ol>
<h3 id="3-2-在隔离级别为读已提交时"><a href="#3-2-在隔离级别为读已提交时" class="headerlink" title="3.2 在隔离级别为读已提交时"></a>3.2 在隔离级别为读已提交时</h3><p>在隔离级别为读已提交时，每一次执行select语句，每次都会重新获取一次最新的ReadView</p>
<table>
<thead>
<tr>
<th align="center">事务</th>
<th align="center">ReadView获取情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &#x3D;1;</td>
<td align="center">获取一次ReanView</td>
</tr>
<tr>
<td align="center">…….</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &#x3D;1;</td>
<td align="center">获取一次ReanView</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3-3-在隔离级别为可重复读时"><a href="#3-3-在隔离级别为可重复读时" class="headerlink" title="3.3 在隔离级别为可重复读时"></a>3.3 在隔离级别为可重复读时</h3><p>在隔离级别为可重复读时，事务开启后只有在第一次select语句后才会获取ReadView，之后的select都是沿用这个ReadView，并不会再去获取新的ReadView</p>
<p><img src="/../images/1-3.png"></p>
<h3 id="3-4-解释2-4思考题"><a href="#3-4-解释2-4思考题" class="headerlink" title="3.4 解释2.4思考题"></a>3.4 解释2.4思考题</h3><p>从以上在两种不同隔离机制下对MVCC的讲解不难看出，由于使用的隔离级别是可重复读的隔离级别，因此，从A事务开始并第一次执行select语句时，就产生了一个ReanView，此后A事务对该条数据进行的查询语句都是基于该版本的记录进行查询，因此B事务对该条数据的操作对A来说是不可见的。</p>
<h3 id="3-5-如何解决幻读"><a href="#3-5-如何解决幻读" class="headerlink" title="3.5 如何解决幻读"></a>3.5 如何解决幻读</h3><p>假设现在student表中有如下所示的一条数据：</p>
<table>
<thead>
<tr>
<th>trx_id&#x3D;10</th>
<th>数据<br />id&#x3D;1,name&#x3D;”张三”，age&#x3D;18</th>
<th>roll_pointer&#x3D;null</th>
</tr>
</thead>
</table>
<p>现有两个事务A，B，他们的id分别是20和30</p>
<p><strong>步骤一：</strong>事务A首先执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;=1; </span><br></pre></td></tr></table></figure>

<p>在开始查询前ReadView的情况如下：trx_ids&#x3D;[20,30]，min_trx_id&#x3D;20 , max_trx_id&#x3D;31 , creator_trx_id&#x3D;20。由于<strong>trx_id&lt;min_tex_id</strong>,所以该条数据对于事务A可见</p>
<p><strong>步骤二：</strong>事务B往表中插入两条数据，并提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(id,name,age) values(2,&#x27;李四&#x27;,12);</span><br><span class="line">insert into student(id,name,age) values(3,&#x27;王五&#x27;,16); </span><br></pre></td></tr></table></figure>

<p><strong>步骤三：</strong>接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p><strong><font  color="red">分析如下</font></strong>:</p>
<ul>
<li><p>对于id&#x3D;1的记录，由于第一次和第二次查询使用的是同一个ReadView，所以该条数据能够被查询出来</p>
</li>
<li><p>对于id&#x3D;2和id&#x3D;3的记录，其实无论B事务提不提交对于A来说B的操作都是不可见的，理由如下：</p>
</li>
<li><p>如果B没有提交事务那么根据上面ReadView使用规则的第四条可以判断B事务新增的记录不可见</p>
</li>
<li><p>如果B提交了事务，此时trx_ids&#x3D;[20]，min_trx_id&#x3D;20，那么根据上面ReadView使用规则的第三条也可以判断这两条记录对于A来说不可见</p>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要讲解了一下几点：</p>
<ul>
<li><a href="#%E4%B8%80.%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">四大隔离级别</a></li>
<li><a href="#%E4%BA%8C.MVCC">MVCC机制及其实现原理</a></li>
<li><a href="#%E4%B8%89.MVCC%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0">MVCC机制如何保证读已提交和可重复读的实现</a></li>
<li>[ReadView的应用规则](#2.3 ReadView的应用规则)</li>
<li>[MVCC如何解决幻读](#3.5 如何解决幻读)</li>
</ul>
<p>希望这篇文章能够让你对MVCC有更好的了解<img src="https://dl4.weshineapp.com/gif/20170714/776d24c1ce2b76a37367b886699a25f0.gif?f=micro_5byA5b+D" alt="img"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之缓存问题</title>
    <url>/2023/efe9ee66.html</url>
    <content><![CDATA[<h1 id="Redis中的缓存问题"><a href="#Redis中的缓存问题" class="headerlink" title="Redis中的缓存问题"></a>Redis中的缓存问题</h1><h2 id="Redis有哪些缓存问题？"><a href="#Redis有哪些缓存问题？" class="headerlink" title="Redis有哪些缓存问题？"></a>Redis有哪些缓存问题？</h2><ul>
<li><strong>缓存预热：</strong>在服务上线之前我们可以提前将MySQL中的数据导入Redis中(可以利用@PostConstruct注解)</li>
<li><strong>缓存雪崩：</strong>当Redis主机挂了，或者全盘崩溃，亦或者大面积的key在同一时间内失效，导致大量请求打到MySQL上</li>
<li><strong>缓存穿透：</strong>请求去查询一条记录，当Redis中没有时，它会去MySQL中查询，结果发现也没用。这样就导致一些无效的非法不存在的数据一直打到MySQL上，给MySQL增加了不必要的压力，使Redis成了一个摆设</li>
<li><strong>缓存击穿：</strong>大量请求查询一个热点key时，这个热点key恰好失效，导致这些请求打到MySQL上，令MySQL在短时间内压力倍增</li>
</ul>
<p>##如何预防和解决这些缓存问题</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>在服务上线之前我们可以提前将MySQL中的数据导入Redis中(可以利用@PostConstruct注解)</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul>
<li><p>key直接设置为永不过期或者错开过期时间</p>
</li>
<li><p>Redis集群实现高可用(主从+哨兵；Redis Cluster；开启Redis持久化机制rdb&#x2F;aof，使之尽快回复Redis缓存)</p>
</li>
<li><p>多缓存结合预防雪崩(cache本地缓存+Redis缓存)</p>
</li>
<li><p>服务降级，使用Hystrix或者阿里sentinel降级，将阻止大量请求打到MySQL上，既是断开服务</p>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>隐患：</strong>既不在Redis，也不在MySQL，容易造成MySQL暴击，黑客也容易利用这点故意制造一些不存在的key频繁大量的攻击你的MySQL服务器，存在一定安全隐患</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>空对象缓存或者缺省。即，每当有不存在的key访问Redis和MySQL无果后，返回null给调用者，然后将这个key设置为null回写Redis，这样，下次这个key再被查询的时候就可以不用查询数据库了，就可以一定程度上缓解穿透问题。<strong>但是，该方案依然存在问题，黑客可以利用不同的不存在的非法key来攻击，这样一方面给你数据库增加不小压力，另一方面Redis会积累许多没用的key</strong></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>使用布隆过滤器，这里不做过多解释，以下是布隆过滤器结合Redis解决穿透的原理图，有兴趣的同学可以去自行了解。</p>
<p><img src="/../images/5-1.png"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>方案一：</strong>设置差异失效时间，对于热点key，干脆不设置失效时间</p>
<p><strong>方案二：</strong>采用双检加锁策略(多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存)</p>
<p><strong>方案三：</strong>使用双缓存机制。对于同一个数据设置两块缓存，主A从B。更新时先更新B，再删除并更新A；查询时，先查询A，如果A没有就查询B缓存。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th align="center">缓存问题</th>
<th align="center">产生原因</th>
<th align="center">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="center">缓存更新方式</td>
<td align="center">数据变更，缓存时效性</td>
<td align="center">同步更新，失效更新，异步更新，定时更新</td>
</tr>
<tr>
<td align="center">缓存不一致</td>
<td align="center">同步更新失败、异步更新</td>
<td align="center">增加重试、补偿任务、最终一致</td>
</tr>
<tr>
<td align="center">缓存穿透</td>
<td align="center">恶意攻击</td>
<td align="center">空对象缓存，布隆过滤器</td>
</tr>
<tr>
<td align="center">缓存击穿</td>
<td align="center">热点key失效</td>
<td align="center">双锁策略，双缓存互斥更新，差异失效时间</td>
</tr>
<tr>
<td align="center">缓存雪崩</td>
<td align="center">缓存挂掉</td>
<td align="center">服务降级熔断，高可用集群</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式七大原则</title>
    <url>/2023/bf020d01.html</url>
    <content><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>简述：对类来说，一个类应该只负责一项职责</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicleroad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicleair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在天上上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehiclesea</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在海上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runroad</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runair</span> <span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在天上上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runsea</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        system.out.println(vehicle + <span class="string">&quot;在海上上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li>demo1中就违反了单一职责原则，demo1中的run方法太笼统，一个类的一个运行方法把所有交通运行方法都处理了，明显不合理。</li>
<li>demo2就是严格遵守单一职责原则，但是存在一定缺陷，每个类都是重复的run方法但是创建了多个类，成本太高了</li>
<li>demo3在方法层面做单一职责，每个方法只负责一个逻辑功能（在方法比较少时比较实用）</li>
</ul>
<h3 id="单一职责原则注意事项"><a href="#单一职责原则注意事项" class="headerlink" title="单一职责原则注意事项"></a>单一职责原则注意事项</h3><ul>
<li><p>降低类的复杂度，一个类只负责一项职责。</p>
</li>
<li><p>提高类的可读性，可维护性</p>
</li>
<li><p>降低变更引起的风险</p>
</li>
<li><p>通常情况下，<strong>我们应当遵守单一职责原则</strong>，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</p>
</li>
</ul>
<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p><strong>介绍：</strong>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖 应该建立在最小的接口上</p>
<p><strong>案例：</strong>接口一由五种方法，A，C两个类分别继承了接口一，B，D分别依赖接口中的方法1，2，4和1，3，5，如此一来就导致了D需要依赖C，但却只用到了C中的1，3，5方法，C实现了D不必要的方法，不是最小接口，AB亦然。</p>
<p><img src="/../images/6-1.png"></p>
<p><strong>代码改进</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">x</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">y</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">z</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">x</span>, y &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">x</span>, z &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>依赖倒转原则(Dependence Inversion Principle)是指：</p>
<ul>
<li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象</p>
</li>
<li><p>依赖倒转(倒置)的中心思想是面向接口编程</p>
</li>
<li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的 多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
</li>
<li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的 任务交给他们的实现类去完成</p>
</li>
</ul>
<h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Email email)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>如果要获取其他信息，如微信，那么我们要新增类，且person类中也要新增方法。但是如果我们把微信，邮件接收信息的方法封装到一个接口中，并让其实现该接口，这样就不用改动客户端，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Receive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">Receive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VX</span> <span class="keyword">implements</span> <span class="title class_">Receive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VX&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Receive receive)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(receive.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInversion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">VX</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="OO中的继承性的思考和说明"><a href="#OO中的继承性的思考和说明" class="headerlink" title="OO中的继承性的思考和说明"></a>OO<strong>中的继承性的思考和说明</strong></h3><ul>
<li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏。</p>
</li>
<li><p>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵 入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p>
</li>
<li><p>问题提出：在编程中，如何正确的使用继承? &#x3D;&gt; <strong>里氏替换原则</strong></p>
</li>
</ul>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里 的女士提出的。</p>
</li>
<li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p>
</li>
<li><p>在使用继承时，遵循里氏替换原则，在子类中<strong>尽量</strong>不要重写父类的方法</p>
</li>
<li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，<strong>在适当的情况下，可以通过聚合，组合，依赖 来解决问题。</strong></p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的 方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完 成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p>
<p><strong>解决方法：</strong>通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉， 采用依赖，聚合，组合等关系代替.</p>
<h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;<span class="comment">//把更加基础的成员和方法写到基类中&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="comment">//如果B需要使用A的方法，使用组合关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="comment">//此处可能是无意重写了A中的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.a.func1(a,b);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁</title>
    <url>/2023/cc4d73b2.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>hello，大家好！今天想和大家分享一些有关Redis分布式锁相关方面的知识，以及如何手写一个分布式锁，废话不多说，我们现在开始。</p>
<h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><ul>
<li>单机版。在同一个JVM虚拟机内的锁，如<strong>synchronized或者Lock接口</strong></li>
<li>分布式。分布在多个JVM虚拟机内，此时单机的线程锁机制已经不起作用了，此时资源并不在同一台服务器上共享</li>
</ul>
<h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>首先，随着业务的不断发展与扩大，我们不可能将所有业务和服务都部署在一台服务器上，肯定涉及到如MySQL的主从复制，Redis集群等等容灾措施。那么此时我们就面临一个问题就是如何让不同的客户端有序的访问同一个共享资源。如果是之前的单机版我们直接上锁即可，但是涉及到分布式，同一个资源整个集群里面的所有服务器共享，当一个客户端请求A发来时，可能经过Nginx反向代理到X服务器并对服务器上的共享资源上锁，但此时又有一个客户端请求B发来时，经过Nginx反向代理可能到Y服务器，此时虽然A对该资源上了锁但是仅仅是对X服务器有效，对于Y来说请求A依旧可以获取相关资源，此时就会发生冲突。可能出现<strong>超卖（在高并发环境下，大量请求同时访问同一个库存资源进行操作。这种情况下，由于多个请求可能同时读取到相同的库存数量，然后都判断库存充足并分别进行扣减操作，导致实际上库存数量被扣减得比实际的要少，从而出现超卖现象）</strong>现象，因此，我们需要分布式锁来对整个分布式集群的共享资源上锁，所有请求必须先获取到这把锁才能进行后续操作。</p>
<p><img src="/../images/4-1.png"></p>
<h3 id="分布式锁解决了那些问题"><a href="#分布式锁解决了那些问题" class="headerlink" title="分布式锁解决了那些问题"></a>分布式锁解决了那些问题</h3><p>####跨进程+跨服务</p>
<p>分布式锁是一种跨进程和跨服务的技术，主要用于解决在分布式环境中多个执行线程访问共享资源时可能出现的数据不一致问题。它可以实现进程间同步访问共享资源，通过全局共享来实现全局锁的效果，从而确保数据一致性。其实现机制一般涉及共享存储系统保存锁变量，加锁和释放锁的过程需要保证操作的原子性</p>
<h4 id="超卖现象"><a href="#超卖现象" class="headerlink" title="超卖现象"></a>超卖现象</h4><p>同上述解释类似，库存这个全局共享资源被加上分布式锁后，所有访问请求都必须获取到这把锁后才能对共享资源进行操作，这样就保证了同一时间只有一个线程对整个Redis集群里面的共享资源进行操作，保证了数据一致性。**(ps:可以思考一下这种情况下如何提高系统并发访问量)**</p>
<h4 id="防止缓存击穿"><a href="#防止缓存击穿" class="headerlink" title="防止缓存击穿"></a>防止缓存击穿</h4><p>当Redis中没有数据时，请求往往会打到数据库上，当有大量请求都去访问数据库时，就会给数据库造成大量负担，存在一定隐患。而分布式锁就可以解决这个问题，当有大量请求过来时，只有第一个请求能拿到锁其他请求线程并进入Redis后发现没有数据，之后就去数据库请求数据，拿到数据后返回客户端并回写Redis，然后释放锁，之后的线程在Redis拿到数据后就不会再去访问数据库，起到了防止缓存击穿的作用。</p>
<h1 id="如何手写一个分布式锁-带你走进分布式锁的原理"><a href="#如何手写一个分布式锁-带你走进分布式锁的原理" class="headerlink" title="如何手写一个分布式锁(带你走进分布式锁的原理)"></a>如何手写一个分布式锁(带你走进分布式锁的原理)</h1><h2 id="一个可靠的分布式锁应具备的刚需"><a href="#一个可靠的分布式锁应具备的刚需" class="headerlink" title="一个可靠的分布式锁应具备的刚需"></a>一个可靠的分布式锁应具备的刚需</h2><p><strong>独占性：</strong>在任何时候都要保证只能有一个线程访问</p>
<p><strong>高可用：</strong>在Redis集群的情况下，不能因为某个节点挂了而出现上锁和解锁失败的情况，同时，在高并发的情景下，依旧能正常运行</p>
<p><strong>防死锁</strong>：杜绝死锁，必须要有超时机制和撤销机制</p>
<p><strong>防乱删：</strong>自己加的锁只能由自己释放，其他线程不能解其他线程的锁</p>
<p><strong>可重入：</strong>同一个节点的同一个线程获取一把锁后，它也可以再次获取这把锁</p>
<h2 id="版本一（setnx-递归调用）"><a href="#版本一（setnx-递归调用）" class="headerlink" title="版本一（setnx+递归调用）"></a>版本一（setnx+递归调用）</h2><p>原理：利用setnx命令先判断当前Redis集群有没有一个变量Lock，如果存在那么说明已经有线程在操作共享资源，此时就要阻塞，循环等待，等待持有锁的线程完成操作后del这把锁，此后其他线程就能进去持有锁(类比一个厕所有很多人要上，每个人进去后先锁门，解决后在开锁开门，之后其他人就能进去了),代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sale</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">retMessage</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;RedisLock&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuidValue</span> <span class="operator">=</span> IdUtil.simpleUUID()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue);</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="comment">//暂停20毫秒后递归调用</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            sale();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//1 查询库存信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;inventory001&quot;</span>);</span><br><span class="line">                <span class="comment">//2 判断库存是否足够</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">inventoryNumber</span> <span class="operator">=</span> result == <span class="literal">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">                <span class="comment">//3 扣减库存</span></span><br><span class="line">                <span class="keyword">if</span>(inventoryNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    stringRedisTemplate.opsForValue().set(<span class="string">&quot;inventory001&quot;</span>,String.valueOf(--inventoryNumber));</span><br><span class="line">                    retMessage = <span class="string">&quot;成功卖出一个商品，库存剩余: &quot;</span>+inventoryNumber;</span><br><span class="line">                    System.out.println(retMessage);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    retMessage = <span class="string">&quot;商品卖完了，o(╥﹏╥)o&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stringRedisTemplate.delete(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retMessage+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;服务端口号：&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺陷：</strong>众所周知，递归存在一个比较明显的问题就是容易“栈溢出”，存在漏洞</p>
<p><strong>改进：</strong>对JUC了解的话我们可以利用JUC里面自旋锁的思想将if改成while防止虚假唤醒，用while循环代替递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue))&#123;</span><br><span class="line">            <span class="comment">//暂停20毫秒，类似CAS自旋</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="版本二-setnx-ttl"><a href="#版本二-setnx-ttl" class="headerlink" title="版本二(setnx+ttl)"></a>版本二(setnx+ttl)</h2><p><strong>版本一存在的问题：</strong>当线程上锁后，服务器宕机，导致该线程无法释放锁，这就导致后续请求无法访问Redis，造成死锁严重影响</p>
<p><strong>解决方法：</strong>可以给锁设置一个ttl过期时间，这样即使宕机无法解锁，那么过期时间一到这把锁就会自动失效，这样后面的线程就能正常访问了</p>
<p><strong>注意事项：</strong>加锁和加过期时间的操作必须保证原子性(原因很简单，如果先加锁，再加过期时间，那么如果加完锁后如果服务器宕机那么给锁加过期时间的操作就没有进行，那么就依旧存在上述问题)</p>
<p><strong>较版本一修改如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue,<span class="number">30L</span>,TimeUnit.SECONDS))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//暂停毫秒</span></span><br><span class="line">           <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="版本三-setnx-ttl-uuid"><a href="#版本三-setnx-ttl-uuid" class="headerlink" title="版本三(setnx+ttl+uuid)"></a>版本三(setnx+ttl+uuid)</h2><p><strong>版本二存在的问题：</strong>虽然版本二给锁加上了过期时间，但是一旦业务处理时间超过了过期时间，那么加的锁就过期失效了，那么其他线程就能访问Redis并设置新的锁，此时如果旧线程完成业务后执行del操作，将新线程的锁删除了之后，就会出现误删的情况，存在一定安全隐患。</p>
<p><strong>改进方法：</strong>加锁时传入一个此线程的uuid，每次删除锁时，需要判断当前线程是否锁的持有线程，如果是则可以正常删除，否则阻塞。</p>
<p><strong>较版本二修改如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(inventoryNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">&quot;inventory001&quot;</span>,String.valueOf(--inventoryNumber));</span><br><span class="line">               retMessage = <span class="string">&quot;成功卖出一个商品，库存剩余: &quot;</span>+inventoryNumber+<span class="string">&quot;\t&quot;</span>+uuidValue;</span><br><span class="line">               System.out.println(retMessage);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               retMessage = <span class="string">&quot;商品卖完了，o(╥﹏╥)o&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// v5.0判断加锁与解锁是不是同一个客户端，同一个才行，自己只能删除自己的锁，不误删他人的</span></span><br><span class="line">           <span class="keyword">if</span>(stringRedisTemplate.opsForValue().get(key).equalsIgnoreCase(uuidValue))&#123;</span><br><span class="line">               stringRedisTemplate.delete(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="版本四-setnx-ttl-uuid-lua"><a href="#版本四-setnx-ttl-uuid-lua" class="headerlink" title="版本四(setnx+ttl+uuid+lua)"></a>版本四(setnx+ttl+uuid+lua)</h2><p><strong>版本三存在的问题：</strong>finally块的判断+del操作不具备原子性</p>
<p><strong>改进方法：</strong>使用lua脚本，将判断和删除整合一起，使之具有原子性，具体的lua脚本学习可以参考官网<br>                    <a href="https://redis.io/docs/reference/patterns/distributed-locks/">官网</a></p>
<p><strong>较版本三修改如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//V6.0 将判断+删除自己的合并为lua脚本保证原子性</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span></span><br><span class="line">                   <span class="string">&quot;if (redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1]) then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;end&quot;</span>;</span><br><span class="line">           stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(luaScript, Boolean.class), Arrays.asList(key), uuidValue);</span><br></pre></td></tr></table></figure>



<h2 id="版本五-setnx-ttl-uuid-lua-可重入"><a href="#版本五-setnx-ttl-uuid-lua-可重入" class="headerlink" title="版本五(setnx+ttl+uuid+lua+可重入)"></a>版本五(setnx+ttl+uuid+lua+可重入)</h2><p><strong>版本四存在的问题：</strong>如何兼顾可重入性问题？关于锁的可重入可以参考JUC相关方面的知识，这里不做过多解释。如果不能实现可重入，那么如果业务需求重复调用该方法，那么第一次调用方法时上锁，第二次再次调用时该线程被自己上一次调用方法上的锁阻塞，这不是作茧自缚吗？因此实现可从入性是衡量一把锁好坏高低的一个重要指标</p>
<p><strong>改进方法：</strong>可重入锁的基本思想就是没锁加锁，如果同一个线程再次请求获得同一把还未解锁的锁，那么计数器+1，lock几次，对应的unlock也要几次，综上，我们可以利用Redis中的hash数据结构**(Map&lt;String,Map&lt;Object,Object&gt;&gt;)**来实现</p>
<p><strong>小总结：</strong></p>
<ul>
<li><strong>setnx</strong>只能解决有无锁的问题</li>
<li><strong>hset</strong>不仅能解决有无，还能解决可重入问题</li>
</ul>
<p>所以，你知道设计一个Redis分布式锁该用什么命令了吗</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h4 id="加锁lua脚本"><a href="#加锁lua脚本" class="headerlink" title="加锁lua脚本"></a>加锁lua脚本</h4><ul>
<li>判断Redis分布式锁的key是否存在</li>
<li>如果返回0不存在，则hset属于自己线程的锁，否则需要进一步判断这把锁是不是属于自己的</li>
<li>如果返回0则说明不是自己的，循环等待；否则，将该锁的计数器+1</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;exists&#x27;</span>,KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">or</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span> </span><br><span class="line"></span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">  redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="解锁lua脚本"><a href="#解锁lua脚本" class="headerlink" title="解锁lua脚本"></a>解锁lua脚本</h4><ul>
<li>判断Redis分布式锁的key是否存在</li>
<li>如果返回0不存在，则程序直接返回nil，否则需要进一步判断这把锁是不是属于自己的</li>
<li>返回0，说明锁不是自己的，不能删除；否则直接调用hincrby -1 对锁进行-1，减至0后直接删除</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span> redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">-1</span>) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>代码修改</strong></p>
<p>将上述加锁解锁lua脚本分别替换while中的循环条件和后续del的lua脚本即可</p>
<p><strong>优化：</strong></p>
<ul>
<li><p>利用juc中的lock接口，通过实现lock接口实现分布式锁</p>
</li>
<li><p>这里只是实现了Redis分布式锁，那万一以后需要MySQL，Zookeeper分布式锁怎么办？所以这里建议引入工厂模式</p>
</li>
</ul>
<h2 id="版本六-setnx-ttl-uuid-lua-可重入-自动续期"><a href="#版本六-setnx-ttl-uuid-lua-可重入-自动续期" class="headerlink" title="版本六(setnx+ttl+uuid+lua+可重入+自动续期)"></a>版本六(setnx+ttl+uuid+lua+可重入+自动续期)</h2><p><strong>版本五存在的问题：</strong>仔细观察会发现其实至始至终都没有解决业务处理时间大于锁的过期时间时的问题，哪怕是<strong>版本三</strong>我们也只是通过加一个uuid判断条件来防止锁被误删，所以我们需要给锁加一个可以自动续期的功能。</p>
<p><strong>改进方法：</strong>通过加一个定时任务，有点类似看门狗策略，每当过期时间过了一段时间后就会自动触发，给锁自动续时间</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">//==============自动续期</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> Vredis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">endV</span><br></pre></td></tr></table></figure>



<p><strong>代码较版本五修改如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;<span class="comment">//KEYS[1]</span></span><br><span class="line">    <span class="keyword">private</span> String uuidValue;<span class="comment">//ARGV[1]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>   expireTime;<span class="comment">//ARGV[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(StringRedisTemplate stringRedisTemplate,String lockName,String uuidValue)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuidValue = uuidValue+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getId();</span><br><span class="line">        <span class="built_in">this</span>.expireTime = <span class="number">30L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;tryLock(-<span class="number">1L</span>,TimeUnit.SECONDS);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 干活的，实现加锁功能，实现这一个干活的就OK，全盘通用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(time != -<span class="number">1L</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.expireTime = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;exists&#x27;,KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;,KEYS[1],ARGV[1]) == 1 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;,KEYS[1],ARGV[1],1) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;script: &quot;</span>+script);</span><br><span class="line">        System.out.println(<span class="string">&quot;lockName: &quot;</span>+lockName);</span><br><span class="line">        System.out.println(<span class="string">&quot;uuidValue: &quot;</span>+uuidValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;expireTime: &quot;</span>+expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script,Boolean.class), Arrays.asList(lockName),uuidValue,String.valueOf(expireTime))) &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.renewExpire();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *干活的，实现解锁功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;HEXISTS&#x27;,KEYS[1],ARGV[1]) == 0 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;elseif redis.call(&#x27;HINCRBY&#x27;,KEYS[1],ARGV[1],-1) == 0 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;   return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="comment">// nil = false 1 = true 0 = false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;lockName: &quot;</span>+lockName);</span><br><span class="line">        System.out.println(<span class="string">&quot;uuidValue: &quot;</span>+uuidValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;expireTime: &quot;</span>+expireTime);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName),uuidValue,String.valueOf(expireTime));</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;This lock doesn&#x27;t EXIST&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;HEXISTS&#x27;,KEYS[1],ARGV[1]) == 1 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName),uuidValue,String.valueOf(expireTime))) &#123;</span><br><span class="line">                    renewExpire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,(<span class="built_in">this</span>.expireTime * <span class="number">1000</span>)/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===下面的redis分布式锁暂时用不到=======================================</span></span><br><span class="line">    <span class="comment">//===下面的redis分布式锁暂时用不到=======================================</span></span><br><span class="line">    <span class="comment">//===下面的redis分布式锁暂时用不到=======================================</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="为什么需要Redis分布式锁"><a href="#为什么需要Redis分布式锁" class="headerlink" title="为什么需要Redis分布式锁"></a>为什么需要Redis分布式锁</h2><p>单机锁只能在一台JVM虚拟机中有效，在集群的不同服务器上如果只用单机锁会存在超卖问题</p>
<h2 id="Redis分布式锁解决了哪些问题"><a href="#Redis分布式锁解决了哪些问题" class="headerlink" title="Redis分布式锁解决了哪些问题"></a>Redis分布式锁解决了哪些问题</h2><ul>
<li>跨进程和跨服务</li>
<li>解决超卖</li>
<li>防止缓存击穿</li>
</ul>
<h2 id="手写Redis分布式锁流程"><a href="#手写Redis分布式锁流程" class="headerlink" title="手写Redis分布式锁流程"></a>手写Redis分布式锁流程</h2><ul>
<li>单机版synchronized，lock锁，面对分布式部署时可能出现超卖现象</li>
<li>使用setnx命令上Redis分布式锁</li>
<li>只是加锁了，但是没有给锁设置过期时间，如果服务器宕机会导致无法解锁，影响后续请求，因此，使用ttl命令给锁设置一个过期时间</li>
<li>加锁和设置过期时间的操作要保证原子性</li>
<li>设置了过期时间可能存在误删锁的情况，所以需要加上一个<strong>uuid</strong>来判断当前线程是否是锁的拥有者，只有自己才能解自己的锁</li>
<li>为了保证<strong>uuid</strong>的判断和<strong>del</strong>删除原子性，我们可以通过引入lua脚本来保证命令原子性</li>
<li>之后为了防止作茧自缚，我们需要让锁具有可重入性</li>
<li>最后，我们需要给锁加个定时任务，到点自动给锁续期，保证在锁的过期时间内能够完成业务</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之锁全家桶</title>
    <url>/2023/74dc7aa6.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>思考一下，我们在面对脏写，脏读，不可重复读，幻读等并发问题时通常有什么解决办法呢？换句话说MySQL是怎么来避免这些问题的呢？其实这里一般有两种解决方案。</p>
<ul>
<li><p>**<font color="red">方案一:</font>**读操作利用MVCC机制(<a href="https://figrowing.github.io/2023/55c34784.html">详情请参照上一篇博客</a>)，写操作通过加锁来实现。</p>
</li>
<li><p>**<font color="red">方案二:</font>**读写操作都通过加锁来实现</p>
</li>
</ul>
<p>通过对以上两种方式对比，我们可以发现方案一采用**<font color="brown">方案一</font><strong>读写操作并不冲突，所以性能相较来说更高，而</strong><font color="brown">方案二</font>**读写操作可能要排队执行，相较来说性能更低。</p>
<p>一般情况下我们更愿意采用MVCC的方式来进行读写操作，但是有些情况就可能必须要用锁来避免并发问题，下面我们就来了解一下MySQL中有哪些锁，以及这些锁分别应用在什么场景。</p>
<h1 id="MySQL中的锁分类"><a href="#MySQL中的锁分类" class="headerlink" title="MySQL中的锁分类"></a>MySQL中的锁分类</h1><p><strong><font color="red">对数据操作类型分类：</font></strong></p>
<ul>
<li>读锁&#x2F;共享锁</li>
<li>写锁&#x2F;排他锁</li>
</ul>
<p><strong><font color="red">锁粒度分类:</font></strong></p>
<p><strong>表级锁：</strong></p>
<pre><code>        * 表级锁的X，S锁
        * 意向锁
        * 自增锁
        * MDL锁
</code></pre>
<p><strong>行级锁:</strong></p>
<ul>
<li>Record Locks（记录锁）</li>
<li>Gap Locks （间隙锁）</li>
<li>Next-Key Locks </li>
<li>插入意向锁</li>
</ul>
<p><strong>页级锁</strong></p>
<p><strong><font color="red">对锁的态度:</font></strong></p>
<ul>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
<p><strong><font color="red">加锁方式:</font></strong></p>
<ul>
<li>显示锁</li>
<li>隐式锁</li>
</ul>
<p><strong><font color="red">其他:</font></strong></p>
<ul>
<li>全局锁</li>
<li>死锁</li>
</ul>
<h1 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h1><p><img src="/../images/3-1.png"></p>
<h2 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h2><ul>
<li><p>读锁 ：也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。</p>
</li>
<li><p>写锁 ：也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p>
</li>
</ul>
<h2 id="按锁粒度分类"><a href="#按锁粒度分类" class="headerlink" title="按锁粒度分类"></a>按锁粒度分类</h2><h3 id="1-表级锁"><a href="#1-表级锁" class="headerlink" title="1.表级锁"></a>1.表级锁</h3><h4 id="1-1-表级别的X，S锁"><a href="#1-1-表级别的X，S锁" class="headerlink" title="1.1 表级别的X，S锁"></a>1.1 表级别的X，S锁</h4><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 S锁 或者 X锁 的。在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 元数据锁 （英文名： Metadata Locks ， 简称 MDL ）结构来实现的。</p>
<ul>
<li>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。</li>
<li>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁。</li>
</ul>
<p>两种表锁模式</p>
<ul>
<li><p>表共享锁（S 锁）</p>
</li>
<li><p>表独占锁（X锁）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">自己是否可读</th>
<th align="center">自己是否可写</th>
<th align="center">他人是否可读</th>
<th align="center">他人是否可写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读锁</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">写锁</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h4 id="1-2-意向锁"><a href="#1-2-意向锁" class="headerlink" title="1.2 意向锁"></a>1.2 意向锁</h4><p><strong><font color="blue">在讲意向锁之前我们先来讲讲意向锁要解决的问题,如下：</font></strong></p>
<p>现在有两个事务T1、T2，其中T2试图在该表级别上加上意向锁共享锁或者意向排他锁，如果没有表级意向锁的存在，那么T2事务就要去遍历该表的所有行判断有没有行锁，假设表有十万数据或者更多，每次都要遍历一次表，那么这将大大影响性能，有了意向锁，那么每次在加行锁的同时加上意向表锁，这样别的事务想要加表锁时只需要检查该表是否存在意向锁即可，无需遍历全表。了解了意向锁的作用后我们来看看意向锁的种类。</p>
<ul>
<li><p>意向共享锁：事务有意向对表中的某些行加共享锁（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line"></span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>意向排他锁：事务有意向对表中的某些行加排他锁（X锁）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line"></span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 他锁时的并发性。（不然我们直接用普通的表锁就行了）</p>
<h4 id="1-3-自增锁"><a href="#1-3-自增锁" class="headerlink" title="1.3 自增锁"></a>1.3 自增锁</h4><p>当有多个事务同时往表里面插入数据时，要先拿到表的自增锁，防止主键出现重复的值</p>
<h4 id="1-4-元数据锁（MDL锁）"><a href="#1-4-元数据锁（MDL锁）" class="headerlink" title="1.4 元数据锁（MDL锁）"></a>1.4 元数据锁（MDL锁）</h4><p>MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</p>
<h3 id="2-行级锁"><a href="#2-行级锁" class="headerlink" title="2.行级锁"></a>2.行级锁</h3><h4 id="2-1-记录锁"><a href="#2-1-记录锁" class="headerlink" title="2.1 记录锁"></a>2.1 记录锁</h4><p>顾名思义，就是把表中的一条数据给锁上。记录锁也分为S和X锁。</p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁；</p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin;</td>
</tr>
<tr>
<td align="center">update student set name &#x3D; “张三” where id &#x3D; 1;(未提交)</td>
<td align="center">update student set name &#x3D; “王五” where id &#x3D; 2;（成功）</td>
</tr>
<tr>
<td align="center">………</td>
<td align="center">update student set name &#x3D; “李四” where id &#x3D; 1;（阻塞）</td>
</tr>
<tr>
<td align="center">commit;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">A事务释放锁，更改完成</td>
</tr>
</tbody></table>
<h4 id="2-2-间隙锁"><a href="#2-2-间隙锁" class="headerlink" title="2.2 间隙锁"></a>2.2 间隙锁</h4><p><strong>Gap锁由来：</strong></p>
<p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方 案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><img src="/../images/3-2.png"></p>
<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是</p>
<p>id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新 记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入 操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<p>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</p>
<h4 id="2-3-临键锁"><a href="#2-3-临键锁" class="headerlink" title="2.3 临键锁"></a>2.3 临键锁</h4><p>有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为</p>
<p>next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，</p>
<p>innodb默认的锁就是Next-Key locks。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line"></span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>



<p>###其实2.3和2.2都是针对幻读问题产生的，但无论是单靠锁机制还是MVCC都无法彻底解决幻读问题，详细可以参考这篇博客， (“墙裂推荐”)[[(2 条消息) 如何理解MySQL中间隙锁可以避免幻读的问题？ - 知乎 (zhihu.com)](<a href="https://www.zhihu.com/question/422425988#:~:text=MySQL">https://www.zhihu.com/question/422425988#:~:text=MySQL</a> InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种： 1 针对 快照读 （普通 select,for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。)] ###</p>
<h4 id="2-4-插入意向锁"><a href="#2-4-插入意向锁" class="headerlink" title="2.4 插入意向锁"></a>2.4 插入意向锁</h4><p>在一个事务向表中插入数据的时候，当要插入的位置被上了Gap锁之后，该事务就进入了等待状态，在这个等待状态下它会被分配一把锁，就是插入意向锁。插入意向锁是一种<font color="red">Gap锁，不是意向锁</font>，是由insert语句产生的锁。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
<h3 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h3><p>页锁的粒度介于表锁和行锁之间，并发度和开销自然也处于两者之间。</p>
<h2 id="按对锁的态度-需要注意的是，乐观锁和悲观锁并不是锁，而是锁的-设计思想"><a href="#按对锁的态度-需要注意的是，乐观锁和悲观锁并不是锁，而是锁的-设计思想" class="headerlink" title="按对锁的态度(需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 设计思想)"></a>按对锁的态度(需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 设计思想)</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁，是一种思想，顾名思义，思想悲观，每当有事务要来取数据的时候，他都会认为事务会更改数据（总有刁民想害朕🙁），所以每次拿数据的时候都会上锁，这样别的事务想拿到这个数据就只能阻塞等待直到拿到锁。Java中 synchronized 和 ReentrantLock 等独占锁就是 悲观锁思想的实现。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过 程序来实现。(例如CAS，版本号机制)，乐观锁适用于读多写少的场景，可以提高并发量。</p>
<h4 id="实现乐观锁的两种机制"><a href="#实现乐观锁的两种机制" class="headerlink" title="实现乐观锁的两种机制"></a>实现乐观锁的两种机制</h4><ol>
<li>版本号机制</li>
</ol>
<p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更 新或删除操作时，会执行 UPDATE … SET version&#x3D;version+1 WHERE version&#x3D;version 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<ol start="2">
<li>时间戳机制</li>
</ol>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。 你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。</p>
<h4 id="两种锁的应用场景"><a href="#两种锁的应用场景" class="headerlink" title="两种锁的应用场景"></a>两种锁的应用场景</h4><ol>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。</li>
</ol>
<h2 id="按加锁的方式"><a href="#按加锁的方式" class="headerlink" title="按加锁的方式"></a>按加锁的方式</h2><h3 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h3><p><strong><font color="red">Look Here!!!</font></strong></p>
<p>在介绍隐式锁之前，我们先来看这样一个场景</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;</td>
<td align="center">begin;</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select * from student</td>
</tr>
<tr>
<td align="center">insert into student values(1,张三，18)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select * from student</td>
</tr>
</tbody></table>
<p>思考一下B事务第二次select查询是什么情况？没错，聪明的你肯定想到了~~阻！塞！等！待！</p>
<p>从这里就可以我们就可以引出有关隐式锁的话题了…….</p>
<h3 id="什么是隐式锁"><a href="#什么是隐式锁" class="headerlink" title="什么是隐式锁"></a>什么是隐式锁</h3><p>一个事务在执行insert语句时(此时没有任何锁结构且<strong>未提交</strong>)，此时突然来了另一个事务</p>
<ul>
<li>立即使用select….. in share mode 来读取这条插入但未提交的数据，此时存在<font color="red">脏读</font>的问题</li>
<li>立即修改这条记录，也就是想获取这条记录的X锁，此时存在<font color="red">脏写</font>的问题</li>
</ul>
<p>这时，我们的隐式锁就起作用了，在一个事务执行insert语句时，会加一个隐式锁，这个锁不会被锁查询语句查询出来，就是用来避免再事务未提交前，其他事务对该条记录进行访问。具体实现就是依靠<font color="red">事务id</font>，如下：</p>
<ul>
<li><p>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务</p>
<p>id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）</p>
</li>
<li><p>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复情景一的做法。</p>
</li>
</ul>
<h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><p>通过特定的语句进行加锁，我们一般称之为显示加锁.</p>
<p>例如： 显示加共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ....  lock in share mode</span><br></pre></td></tr></table></figure>

<p>显示加排他锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ....  for update</span><br></pre></td></tr></table></figure>





<h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><h3 id="其他锁之全局锁"><a href="#其他锁之全局锁" class="headerlink" title="其他锁之全局锁"></a>其他锁之全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份</p>
<p>全局锁的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>



<h3 id="其他锁之死锁"><a href="#其他锁之死锁" class="headerlink" title="其他锁之死锁"></a>其他锁之死锁</h3><p>玩归玩，闹归闹，别拿死锁开玩笑~~</p>
<p><strong>定义：</strong>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p>死锁示例：</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;<br />update student set name &#x3D; “张三” where id &#x3D; 1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin;<br />update student set name &#x3D; “李四” where id &#x3D; 2;</td>
</tr>
<tr>
<td align="center">begin;<br />update student set name &#x3D; “王五” where id &#x3D; 2;</td>
<td align="center">begin;<br />update student set name &#x3D; “赵六” where id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">……..阻塞等待，直到超时</td>
<td align="center">…….阻塞等待，直到超时</td>
</tr>
</tbody></table>
<p><img src="https://dl4.weshineapp.com/gif/20170321/15cb1189cd94ccaae2151070ae339adb.gif?f=micro_5pCe5LqL5oOF" alt="img"></p>
<p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务2在等待事务1释放id&#x3D;1的行锁。 事务1和事务2在互 相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有 两种策略 ：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级 排他锁的事务进行回滚），让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为on ，表示开启这个逻辑。</li>
</ul>
<p>第二种策略的成本分析 </p>
<p>方法1：如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有 一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后 通过业务重试一般就没问题了，这是 业务无损 的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损 的。</p>
<p>方法2：控制并发度。如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测 的成本很低，就不会出现这个问题。 这个并发控制要做在 数据库服务端 。如果你有中间件，可以考虑在 中间件实现 ；甚至有能力修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇博客主要介绍了MySQL的锁家族，对各种分门别类的锁也做了相应的讲解，希望对大家和自己有所帮助！想必看到这里的也是真爱了，哈哈哈哈。看完不妨照着顶上的锁图自己回想一下各种锁的分类以及作用。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis双写一致性</title>
    <url>/2023/b0280743.html</url>
    <content><![CDATA[<h1 id="双写一致性是什么？"><a href="#双写一致性是什么？" class="headerlink" title="双写一致性是什么？"></a>双写一致性是什么？</h1><h2 id="什么是双写？"><a href="#什么是双写？" class="headerlink" title="什么是双写？"></a>什么是双写？</h2><p>双写其实是针对Redis缓存和MySQL数据库来说的，是指在写入数据时，将数据同时写入两个地方，一个是数据库，另一个是缓存。这样，当读取数据时，首先从缓存中读取，如果缓存中没有数据，则从数据库中读取并将其写入缓存。这种方法可以提高读取速度并减少对数据库的访问次数。</p>
<h2 id="什么又是双写一致性？"><a href="#什么又是双写一致性？" class="headerlink" title="什么又是双写一致性？"></a>什么又是双写一致性？</h2><p>简单来说就是要保证数据库和Redis的数据要一致。</p>
<ul>
<li>如果Redis中有数据，则要和MySQL保持一致</li>
<li>如果Redis中没有数据，则要将MySQL中最新值回写Redis</li>
</ul>
<p><img src="/../images/7-1.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById2</span><span class="params">(Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_KEY_USER+id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 先从redis里面查询，如果有直接返回结果，如果没有再去查询mysql，</span></span><br><span class="line">        <span class="comment">// 第1次查询redis，加锁前</span></span><br><span class="line">        user = (User) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2 大厂用，对于高QPS的优化，进来就先加锁，保证一个请求操作，让外面的redis等待一下，避免击穿mysql</span></span><br><span class="line">            <span class="keyword">synchronized</span> (UserService.class)&#123;</span><br><span class="line">                <span class="comment">//第2次查询redis，加锁后</span></span><br><span class="line">                user = (User) redisTemplate.opsForValue().get(key);</span><br><span class="line">                <span class="comment">//3 二次查redis还是null，可以去查mysql了(mysql默认有数据)</span></span><br><span class="line">                <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//4 查询mysql拿数据(mysql默认有数据)</span></span><br><span class="line">                    user = userMapper.selectByPrimaryKey(id);</span><br><span class="line">                    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//5 mysql里面有数据的，需要回写redis，完成数据一致性的同步工作</span></span><br><span class="line">                        redisTemplate.opsForValue().setIfAbsent(key,user,<span class="number">7L</span>,TimeUnit.DAYS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数据库与缓存双写更新策略"><a href="#数据库与缓存双写更新策略" class="headerlink" title="数据库与缓存双写更新策略"></a>数据库与缓存双写更新策略</h1><h2 id="可以停机的情况"><a href="#可以停机的情况" class="headerlink" title="可以停机的情况"></a>可以停机的情况</h2><p>服务降级，挂牌报错，建议直接开启单线程同步数据，不过一般生产环境下不允许停机</p>
<h2 id="先更新数据库，在更新缓存"><a href="#先更新数据库，在更新缓存" class="headerlink" title="先更新数据库，在更新缓存"></a>先更新数据库，在更新缓存</h2><p><strong>问题一：</strong></p>
<p>在更新玩数据库之后，如果回写失败，则会导致Redis与数据库中数据不一致</p>
<p><strong>问题二：</strong></p>
<p>在高并发环境下，由于存在网络延迟等问题，如果有两个线程执行以下操作</p>
<table>
<thead>
<tr>
<th align="center">线程A</th>
<th align="center">线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">update MySQL 100</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update MySQL 80</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update Redis 80</td>
</tr>
<tr>
<td align="center">update Redis 100</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这样就可能导致Redis和MySQL中数据不一致</p>
<p>##先更新缓存，再更新数据库</p>
<p>###问题一</p>
<p>一般业务最终都是以数据库数据为最后评判标准，如果先更新缓存再更新数据库，会导致数据库中的值为旧值，当出现意外时就会以数据库旧值作为标准，存在安全隐患</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>在高并发环境下，由于存在网络延迟等问题，如果有两个线程执行以下操作</p>
<table>
<thead>
<tr>
<th align="center">线程A</th>
<th align="center">线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">update Redis 100</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update Redis 80</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update MySQL 80</td>
</tr>
<tr>
<td align="center">update MySQL 100</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这样就可能导致Redis和MySQL中数据不一致</p>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力导致打满mysql</p>
<h3 id="问题二-1"><a href="#问题二-1" class="headerlink" title="问题二"></a>问题二</h3><ul>
<li><p>请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql……A还么有彻底更新完mysql，还没commit</p>
</li>
<li><p>请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)</p>
</li>
<li><p>请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)</p>
</li>
<li><p>请求B将旧值写回redis缓存</p>
</li>
<li><p>请求A将新值写入mysql数据库</p>
</li>
</ul>
<p>上述情况就会导致不一致的情形出现。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">线程A</th>
<th align="center">线程B</th>
<th align="center">存在的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">请求A进行写操作，删除缓存成功后，工作正在mysql进行中……</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center"></td>
<td align="center">1 缓存中读取不到，立刻读mysql，由于A还没对mysql更新完，读到的是旧值<br />2 还把从mysql读取的旧值，写回了redis</td>
<td align="center">1 A还没有更新完mysql，导致B读到了旧值<br />2 线程B遵守回写机制，把旧值写回redis，导致其它请求读取的还是旧值，A白干了</td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center">A更新完mysql数据库的值，over</td>
<td align="center"></td>
<td align="center">redis是被B写回的旧值，<br />mysql是被A更新的新值。<br />出现了，数据不一致问题。</td>
</tr>
</tbody></table>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>先删缓存，再更新数据库如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis，导致A白干了。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>采用延时双删策略</strong>，即更新数据库的线程操作完成后先睡眠一段时间，结束时间后再将缓存删掉(此时删除的是B线程回写Redis的脏数据)，<strong>但是要确保线程A睡眠的时间要大于线程B读取数据和回写Redis的时间，此处可以采用看门狗策略</strong></p>
<h2 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h2><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">线程A</th>
<th align="center">线程B</th>
<th align="center">存在的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">更新数据库中的值……</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center"></td>
<td align="center">缓存立即命中，此时读取的是Redis中的旧值</td>
<td align="center">A还没来得及删除缓存导致B读取的是旧值</td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center">更新缓存数据</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>先更新数据库，再删除缓存。假如删除缓存失败或来不及，将会导致<strong>再次访问Redis时缓存命中，访问的是旧值。</strong></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><img src="/../images/7-2.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../images/7-3.png"></p>
<p>通过分析以上四种双写策略我们不难发现，在实际生产中要做到实时一致性几乎不可能，我们所能做到的只是根据不同的业务场景选择最合适的双写策略来减少双写所带来的问题。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何安装MySQL</title>
    <url>/2024/76bb6795.html</url>
    <content><![CDATA[<h1 id="Linux如何安装MySQL（MySQL-8-0）"><a href="#Linux如何安装MySQL（MySQL-8-0）" class="headerlink" title="Linux如何安装MySQL（MySQL 8.0）"></a>Linux如何安装MySQL（MySQL 8.0）</h1><h2 id="1-1-Linux系统及工具的准备"><a href="#1-1-Linux系统及工具的准备" class="headerlink" title="1.1 Linux系统及工具的准备"></a>1.1 Linux系统及工具的准备</h2><ul>
<li>安装并启动虚拟机： CentOS 7</li>
<li>掌握克隆虚拟机的操作</li>
<li>mac地址 主机名</li>
<li>ip地址</li>
<li>UUID</li>
<li>安装有 Xshell 和 Xftp 等访问CentOS系统的工具</li>
<li>确保主机能联网</li>
</ul>
<h2 id="1-2-检查一下是否安装过MySQL"><a href="#1-2-检查一下是否安装过MySQL" class="headerlink" title="1.2 检查一下是否安装过MySQL"></a>1.2 检查一下是否安装过MySQL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql  <span class="comment"># -i 忽略大小写 </span></span><br><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure>

<h2 id="1-3卸载MySQL"><a href="#1-3卸载MySQL" class="headerlink" title="1.3卸载MySQL"></a>1.3卸载MySQL</h2><p><strong>1.关闭 mysql 服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure>

<p><strong>2.查看当前 mysql 安装状况</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql </span><br><span class="line"></span><br><span class="line"><span class="comment"># 或 </span></span><br><span class="line"></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.卸载上述命令查询出的已安装程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx</span><br></pre></td></tr></table></figure>

<p><strong>务必卸载干净，反复执行 rpm -qa | grep -i mysql 确认是否有卸载残留</strong></p>
<p><strong>4.删除 mysql 相关文件</strong></p>
<p>查找相关文件 删除上述命令查找出的相关文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>

<p>删除命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf xxx</span><br></pre></td></tr></table></figure>

<p><strong>5.删除 my.cnf</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /etc/my.cnf</span><br></pre></td></tr></table></figure>

<h2 id="1-4下载MySQL安装包"><a href="#1-4下载MySQL安装包" class="headerlink" title="1.4下载MySQL安装包"></a>1.4下载MySQL安装包</h2><p><strong>下载地址</strong></p>
<p>官网：<a href="https://www.mysql.com/">https://www.mysql.com</a></p>
<p><strong>安装包提取并上传</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql-community-common-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-libs-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-client-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-server-8.0.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h2 id="1-5解决依赖并安装"><a href="#1-5解决依赖并安装" class="headerlink" title="1.5解决依赖并安装"></a>1.5解决依赖并安装</h2><p>在上面五个包所处的目录下<strong>按序</strong>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>rpm</strong> 是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的 文件形式，易于安装。</li>
<li><strong>-i</strong> , –install 安装软件包</li>
<li><strong>-v</strong> , –verbose 提供更多的详细信息输出</li>
<li><strong>-h</strong> , –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li>
</ul>
<p><strong>遇到的报错</strong></p>
<p><img src="/../images/8-1.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove mysql-libs</span><br></pre></td></tr></table></figure>

<h2 id="1-6查看MySQL的版本（检查是否安装成功）"><a href="#1-6查看MySQL的版本（检查是否安装成功）" class="headerlink" title="1.6查看MySQL的版本（检查是否安装成功）"></a>1.6查看MySQL的版本（检查是否安装成功）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure>

<h2 id="1-7服务初始化"><a href="#1-7服务初始化" class="headerlink" title="1.7服务初始化"></a>1.7服务初始化</h2><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执 行下面的命令初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure>

<p>说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将 该密码标记为过 期 ，登录后你需要设置一个新的密码。生成的 临时密码 会往日志中记录一份。 查看密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<h2 id="1-8-启动MySQL"><a href="#1-8-启动MySQL" class="headerlink" title="1.8 启动MySQL"></a>1.8 启动MySQL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>

<h2 id="1-9首次登录"><a href="#1-9首次登录" class="headerlink" title="1.9首次登录"></a>1.9首次登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>然后输入临时密码登录</p>
<h2 id="1-10修改密码"><a href="#1-10修改密码" class="headerlink" title="1.10修改密码"></a>1.10修改密码</h2><p><strong>因为临时密码是会过期的，所以必须要修改密码，否则无法使用数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;new_password&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p><strong>至此，MySQL成功安装</strong></p>
<h1 id="远程连接登录MySQL"><a href="#远程连接登录MySQL" class="headerlink" title="远程连接登录MySQL"></a>远程连接登录MySQL</h1><p><strong>MySQL的默认配置是不支持远程连接的，</strong>所以如果我们想要使用一些sqlyog，DataGrip，Navicat等第三方连接工具，需要修改一些配置。</p>
<h2 id="2-1-关闭防火墙"><a href="#2-1-关闭防火墙" class="headerlink" title="2.1 关闭防火墙"></a>2.1 关闭防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld //关闭防火墙</span><br><span class="line">systemctl disable firewalld.service //开机自动关闭</span><br></pre></td></tr></table></figure>

<h2 id="2-2-登录MySQL，修改配置"><a href="#2-2-登录MySQL，修改配置" class="headerlink" title="2.2 登录MySQL，修改配置"></a>2.2 登录MySQL，修改配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>Host列指定了允许用户登录所使用的IP，比如user&#x3D;root Host&#x3D;192.168.1.1。这里的意思就是说root用户只 能通过192.168.1.1的客户端去访问。 user&#x3D;root Host&#x3D;localhost，表示只能通过本机客户端去访问。而 %是个 通配符 ，如果Host&#x3D;192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连 接。如果 Host&#x3D;% ，表示所有IP都有连接权限。 注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产 环境的IP进行设置。Host设置了“%”后便可以允许远程访问。</p>
<h2 id="2-3-刷新配置"><a href="#2-3-刷新配置" class="headerlink" title="2.3 刷新配置"></a>2.3 刷新配置</h2><p>修改完了配置之后需要刷新配置才能够生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-修改加密方法"><a href="#2-4-修改加密方法" class="headerlink" title="2.4 修改加密方法"></a>2.4 修改加密方法</h2><p>登录Linux的mysql库，执行这条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>至此，MySQL已经能够被远程连接访问了</strong></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>如何上线和部署一个项目</title>
    <url>/2024/a77db1b1.html</url>
    <content><![CDATA[<h1 id="部署-上线"><a href="#部署-上线" class="headerlink" title="部署 &amp; 上线"></a>部署 &amp; 上线</h1><h2 id="公网能够访问到的一台服务器"><a href="#公网能够访问到的一台服务器" class="headerlink" title="公网能够访问到的一台服务器"></a>公网能够访问到的一台服务器</h2><p>我们的项目一般只能使用本地localhost地址来自己访问，要想要其他人也能够访问到我们的项目，需要一台能够在公网访问到的服务器，这里我们就需要向一些云服务厂商(阿里云，腾讯云，华为云等)购买。推荐安装Centos7.6及以上版本或者Linux宝塔界面系统（对新手比较友好），最低配2核2G。</p>
<h3 id="配置安全组（防火墙）"><a href="#配置安全组（防火墙）" class="headerlink" title="配置安全组（防火墙）"></a>配置安全组（防火墙）</h3><p>刚买来的服务器仅开放很少的端口，你需要将自己需要的端口自行打开，不然你的请求会被拒绝，例如一些常用端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80:http</span><br><span class="line">443:https</span><br><span class="line">3306:MySQL</span><br><span class="line">22:SSH</span><br><span class="line">6379:redis</span><br></pre></td></tr></table></figure>



<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>部署前端项目，我们需要把我们的一些页面交由Web服务器来管理，以便用户能够正常访问我们的前端项目入口页面。</p>
<p><strong>常见的Web服务器：</strong></p>
<ul>
<li>Nginx</li>
<li>tomcat</li>
<li>apache</li>
</ul>
<p>我们这里使用的是<strong>Nginx</strong></p>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz</span><br><span class="line">tar -zxvf nginx-1.21.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>下载<strong>Xshell</strong>和<strong>Xftp</strong>远程访问工具</p>
<p>将xshell和xftp连接到远程服务器之后你可以先在官网下载nginx-1.21.6.tar.gz包，然后直接通过Xftp拖入Linux服务器中。</p>
<h3 id="下载Nginx依赖，编译"><a href="#下载Nginx依赖，编译" class="headerlink" title="下载Nginx依赖，编译"></a>下载Nginx依赖，编译</h3><p><strong>依赖下载：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc //下载编译器</span><br><span class="line">yum install -y pcre pcre-devel //下载依赖</span><br><span class="line">yum install -y zlib zlib-devel //下载依赖</span><br></pre></td></tr></table></figure>

<p><strong>编译：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>编译完成后，nginx目录会安装到你服务器的**&#x2F;usr&#x2F;local**目录下</p>
<p><strong>修改配置文件：</strong></p>
<p>进入nginx目录中的Conf目录，修改nginx.conf配置文件，将你前端文件的目录路径放到<strong>location</strong>配置中，这个配置是nginx访问的默认位置 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   //前端文件目录所在路径;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            //try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>开启进程所有者：</strong></p>
<p>还是这个conf目录第一行有一行注释 “# user root”，将前面这个“#”去掉，打开nginx进程的所有者，不然会被403墙掉。</p>
<p><strong>重新加载配置文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s re1oad //重新加载配置</span><br></pre></td></tr></table></figure>



<p><strong>启动Nginx：</strong></p>
<p>去到nginx目录的bin目录下执行启动命令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx //启动命令</span><br></pre></td></tr></table></figure>

<p><strong>关闭防火墙：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<p>直接浏览器访问你的服务器IP地址，如果成功展示你的页面即成功。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h2 id="安装数据库，Java，Nacos等"><a href="#安装数据库，Java，Nacos等" class="headerlink" title="安装数据库，Java，Nacos等"></a>安装数据库，Java，Nacos等</h2><p><strong>数据库：</strong></p>
<p>如果你比较豪，可以直接购买云服务厂商的数据库服务，如果没有则也可以自己在服务器上安装，这里给个安装教程链接，你也可以网上自行搜索相关教程</p>
<p><strong>Java：</strong></p>
<p>直接执行以下安装命令即可，你也可以将自己电脑本地的JDK包使用Xftp拖拽进服务器（不过这种方式需要手动配置系统环境），建议安装JDK11及以上的版本（PS：有时候会报版本太低无法运行的错误）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-11-openjdk*</span><br></pre></td></tr></table></figure>

<p><strong>验证：</strong></p>
<p>执行命令，如果成功显示你所使用的java版本及安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure>

<h2 id="打包本地后端项目代码"><a href="#打包本地后端项目代码" class="headerlink" title="打包本地后端项目代码"></a>打包本地后端项目代码</h2><h3 id="使用maven-命令打包"><a href="#使用maven-命令打包" class="headerlink" title="使用maven 命令打包"></a>使用maven 命令打包</h3><p><strong>打开终端，执行install</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install</span><br></pre></td></tr></table></figure>

<p>生成jar包文件后上传至服务器</p>
<p><strong>执行jar包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar ./你的jar包名称 <span class="comment">//当前终端执行</span></span><br><span class="line">nohup java -jar ./你的jar包名称 &amp;  <span class="comment">// 后台执行 </span></span><br><span class="line">jobs <span class="comment">//查看后台进程命令</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列的确认和持久化机制</title>
    <url>/2024/49306358.html</url>
    <content><![CDATA[<h1 id="消息的确认和持久化机制"><a href="#消息的确认和持久化机制" class="headerlink" title="消息的确认和持久化机制"></a>消息的确认和持久化机制</h1><h2 id="为什么需要持久化机制"><a href="#为什么需要持久化机制" class="headerlink" title="为什么需要持久化机制"></a>为什么需要持久化机制</h2><p>其实我们的RabbitMQ消息队列的交换机，队列，消息等都是在<strong>内存</strong>中工作的，在内存中意味着什么，是不是一旦RabbitMQ宕机了，我们消息队列上的消息，和队列，交换机等会全部丢失，这样的话会造成消息丢失，会影响我们整个服务，可能会造成严重后果。</p>
<h2 id="为什么需要消息的消费确认机制"><a href="#为什么需要消息的消费确认机制" class="headerlink" title="为什么需要消息的消费确认机制"></a>为什么需要消息的消费确认机制</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。  为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了</strong></p>
<h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">basicConsume</span><span class="params">(String queue, <span class="type">boolean</span> autoAck, DeliverCallback deliverCallback, CancelCallback cancelCallback)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p><strong>这是消息队列消费者消费消息的接口</strong></p>
<p><strong>queue</strong>：队列名称</p>
<p><strong>autoAck：</strong>是否开启自动应答</p>
<p><strong>DeliverCallback：</strong>消息回调接口，接收到消息后通过这个接口处理消息</p>
<p><strong>CancelCallback：</strong>取消消息订阅时调用 的接口</p>
<p>我们只需要在消费者方将autoAck设置为<strong>true</strong>即可开启自动应答模式，这样，只要消费者收到了消息自动会返回一个ack确认。</p>
<p><strong>存在的问题：</strong></p>
<p><strong>消息发送后立即被认为已经传送成功</strong>，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用</strong>。</p>
<h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><p><strong>A</strong>.Channel.basicAck(用于肯定确认)  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p>
<p><strong>B</strong>.Channel.basicNack(用于否定确认) </p>
<p><strong>C</strong>.Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数  不处理该消息了直接拒绝，可以将其丢弃了 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">channel.basicNack(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">channel.basicReject(deliveryTag);</span><br></pre></td></tr></table></figure>

<p>第二个参数<strong>Multiple 的解释</strong></p>
<p>multiple 的 true 和 false 代表不同意思  true 代表批量应答 channel 上未应答的消息  比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时  5-8 的这些还未应答的消息都会被确认收到消息应答  false 同上面相比  只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答。但很明显，这个策略存在问题，一旦之前的消息没有被消费或者消费失败，将它们一起应答之后，消息生产者就会将他们删除，这样就造成了消息丢失的问题。所以，一般我们不开启该功能。</p>
<h3 id="消息的重新入队"><a href="#消息的重新入队" class="headerlink" title="消息的重新入队"></a>消息的重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息</p>
<p>通过上面的消息确认和消息重新入队，我们可以做到<strong>一定程度上</strong>消息的不丢失</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标 记为持久化</strong></p>
<h3 id="队列的持久化"><a href="#队列的持久化" class="headerlink" title="队列的持久化"></a>队列的持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.DeclareOk <span class="title function_">queueDeclare</span><span class="params">(String queue, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive, <span class="type">boolean</span> autoDelete,</span></span><br><span class="line"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，<strong>MessageProperties.PERSISTENT_TEXT_PLAIN</strong> 添加这个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                       message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考发布确认的知识。</p>
<h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><p>RabbitMQ的发布确认是一种<strong>确保消息可靠性的机制，它允许生产者确认消息是否已经被RabbitMQ服务器接收，告诉消息生产者，消息已经保存到磁盘中了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开启发布确认 </span><br><span class="line"> channel.confirmSelect(); </span><br></pre></td></tr></table></figure>

<h3 id="单个发布确认"><a href="#单个发布确认" class="headerlink" title="单个发布确认"></a>单个发布确认</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>; </span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes()); </span><br><span class="line"> <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发 </span></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms(); </span><br><span class="line"> <span class="keyword">if</span>(flag)&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;消息发送成功&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。  这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢，</strong>因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p>
<h3 id="批量发布确认"><a href="#批量发布确认" class="headerlink" title="批量发布确认"></a>批量发布确认</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启发布确认 </span></span><br><span class="line"> channel.confirmSelect(); </span><br><span class="line"> <span class="comment">//批量确认消息大小 </span></span><br><span class="line"> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line"> <span class="comment">//未确认消息个数 </span></span><br><span class="line"> <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"> <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>; </span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes()); </span><br><span class="line"> outstandingMessageCount++; </span><br><span class="line"> <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123; </span><br><span class="line"> channel.waitForConfirms(); </span><br><span class="line"> outstandingMessageCount = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:<strong>当发生故障导致发布出现问题时，不知道是哪个消息出现问题了</strong>，我们必须将<strong>整个批处理保存在内存中</strong>，以记录重要的信息而后重新发布消息。当然这种 方案仍然是<strong>同步</strong>的，也一样<strong>阻塞消息的发布</strong>。</p>
<h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><p>他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，拥有较高的可靠性和效率。</p>
<p><strong>流程</strong></p>
<p><img src="/../images/9-1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString(); </span><br><span class="line"> channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>); </span><br><span class="line"> <span class="comment">//开启发布确认 </span></span><br><span class="line"> channel.confirmSelect(); </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 线程安全有序的一个哈希表，适用于高并发的情况 </span></span><br><span class="line"><span class="comment"> * 1.轻松的将序号与消息进行关联 </span></span><br><span class="line"><span class="comment"> * 2.轻松批量删除条目 只要给到序列号 </span></span><br><span class="line"><span class="comment"> * 3.支持并发访问 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> </span><br><span class="line"></span><br><span class="line"><span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;(); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 确认收到消息的一个回调 </span></span><br><span class="line"><span class="comment"> * 1.消息序列号 </span></span><br><span class="line"><span class="comment"> * 2.true 可以确认小于等于当前序列号的消息 </span></span><br><span class="line"><span class="comment"> * false 确认当前序列号消息 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123; </span><br><span class="line"> <span class="keyword">if</span> (multiple) &#123; </span><br><span class="line"> <span class="comment">//返回的是小于等于当前序列号的未确认消息 是一个 map </span></span><br><span class="line"> ConcurrentNavigableMap&lt;Long, String&gt; confirmed = </span><br><span class="line"></span><br><span class="line">outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>); </span><br><span class="line"> <span class="comment">//清除该部分未确认消息 </span></span><br><span class="line"> confirmed.clear(); </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line"> <span class="comment">//只清除当前序列号的消息 </span></span><br><span class="line"> outstandingConfirms.remove(sequenceNumber); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber); </span><br><span class="line"> System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 添加一个异步确认的监听器 </span></span><br><span class="line"><span class="comment"> * 1.确认收到消息的回调 </span></span><br><span class="line"><span class="comment"> * 2.未收到消息的回调 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> channel.addConfirmListener(ackCallback, <span class="literal">null</span>); </span><br><span class="line"> <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i; </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * channel.getNextPublishSeqNo()获取下一个消息的序列号 </span></span><br><span class="line"><span class="comment"> * 通过序列号与消息体进行一个关联 </span></span><br><span class="line"><span class="comment"> * 全部都是未确认的消息体 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> outstandingConfirms.put(channel.getNextPublishSeqNo(), message); </span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line"> System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;ms&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>三种方式对比</strong></p>
<p>单独发布消息  同步等待确认，简单，但吞吐量非常有限。</p>
<p>批量发布消息  批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条  消息出现了问题.</p>
<p>异步处理：  最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>
<h3 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h3><p>之前我们讲的发布确认只是，RabbitMQ收到消息并保存在磁盘中后，给生产者发送一个Ack确认机制，但是，如果生产者发送了消息，但是交换机或者队列出了问题，无法接受，<strong>也就是生产者发了消息给交换机，或者队列，但是其中交换机或者队列之一出了问题，没有收到，之前的发布确认是防止RabbitMQ重启消息丢失，这个时防止消息投递失败</strong></p>
<p><strong>原理和架构图</strong></p>
<p><img src="/../images/9-2.png"></p>
<p><img src="/../images/9-4.png" alt="9-4"></p>
<p>在配置文件当中需要添加 </p>
<p><strong>spring.rabbitmq.publisher-confirm-type&#x3D;correlated</strong> </p>
<p>⚫ NONE  禁用发布确认模式，是默认值 </p>
<p>⚫ CORRELATED  发布消息成功到交换器后会触发回调方法 </p>
<p>⚫ SIMPLE </p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><strong>回调接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@Slf4j</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123; </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 交换机不管是否收到消息的一个回调方法 </span></span><br><span class="line"><span class="comment"> * CorrelationData </span></span><br><span class="line"><span class="comment"> * 消息相关数据 </span></span><br><span class="line"><span class="comment"> * ack </span></span><br><span class="line"><span class="comment"> * 交换机是否收到消息 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123; </span><br><span class="line"> String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span>(ack)&#123; </span><br><span class="line"> log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id); </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line"> log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>注入消息生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span> </span><br><span class="line"><span class="meta">@Slf4j</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>; </span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> <span class="keyword">private</span> RabbitTemplate rabbitTemplate; </span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> <span class="keyword">private</span> MyCallBack myCallBack; </span><br><span class="line"> <span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象 </span></span><br><span class="line"> <span class="meta">@PostConstruct</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123; </span><br><span class="line"> rabbitTemplate.setConfirmCallback(myCallBack); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h4><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback , </span><br><span class="line">RabbitTemplate.ReturnCallback &#123; </span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> <span class="keyword">private</span> RabbitTemplate rabbitTemplate; </span><br><span class="line"> <span class="comment">//rabbitTemplate 注入之后就设置该值 </span></span><br><span class="line"> <span class="meta">@PostConstruct</span> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; </span><br><span class="line"> rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>); </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * true： </span></span><br><span class="line"><span class="comment"> * 交换机无法将消息进行路由时，会将该消息返回给生产者 </span></span><br><span class="line"><span class="comment"> * false： </span></span><br><span class="line"><span class="comment"> * 如果发现消息无法进行路由，则直接丢弃 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> rabbitTemplate.setMandatory(<span class="literal">true</span>); </span><br><span class="line"> <span class="comment">//设置回退消息交给谁处理 </span></span><br><span class="line"> rabbitTemplate.setReturnCallback(<span class="built_in">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@GetMapping(&quot;sendMessage&quot;)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123; </span><br><span class="line"> <span class="comment">//让消息绑定一个 id 值 </span></span><br><span class="line"> <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">   rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key1&quot;</span>,message+<span class="string">&quot;key1&quot;</span>,correlationData1)</span><br><span class="line">; </span><br><span class="line"> log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="string">&quot;key1&quot;</span>); </span><br><span class="line"> <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString()); </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key2&quot;</span>,message+<span class="string">&quot;key2&quot;</span>,correlationData2)</span><br><span class="line">; </span><br><span class="line"> log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="string">&quot;key2&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (ack) &#123; </span><br><span class="line"> log.info(<span class="string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> log.error(<span class="string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String </span></span><br><span class="line"><span class="params">exchange, String routingKey)</span> &#123; </span><br><span class="line"> log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>, </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),replyText, exchange, routingKey); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>
<p><strong>架构图</strong></p>
<p><img src="/../images/9-3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明确认 Exchange 交换机的备份交换机 </span></span><br><span class="line"> <span class="meta">@Bean(&quot;confirmExchange&quot;)</span> </span><br><span class="line"> <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123; </span><br><span class="line"> <span class="type">ExchangeBuilder</span> <span class="variable">exchangeBuilder</span> <span class="operator">=</span> </span><br><span class="line"> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME) </span><br><span class="line"> .durable(<span class="literal">true</span>) </span><br><span class="line"> <span class="comment">//设置该交换机的备份交换机 </span></span><br><span class="line"> .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME); </span><br><span class="line"> <span class="keyword">return</span> (DirectExchange)exchangeBuilder.build(); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 声明警告队列 </span></span><br><span class="line"> <span class="meta">@Bean(&quot;warningQueue&quot;)</span> </span><br><span class="line"> <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 声明报警队列绑定关系 </span></span><br><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"> <span class="keyword">public</span> Binding <span class="title function_">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue, </span></span><br><span class="line"><span class="params"> <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange </span></span><br><span class="line"><span class="params">backupExchange)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 声明备份队列 </span></span><br><span class="line"> <span class="meta">@Bean(&quot;backQueue&quot;)</span> </span><br><span class="line"> <span class="keyword">public</span> Queue <span class="title function_">backQueue</span><span class="params">()</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 声明备份队列绑定关系 </span></span><br><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"> <span class="keyword">public</span> Binding <span class="title function_">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue, </span></span><br><span class="line"><span class="params"> <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>死信队列</title>
    <url>/2024/1e54fa56.html</url>
    <content><![CDATA[<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a><strong>死信的概念</strong></h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。 </p>
<p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效 </p>
<h2 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a><strong>死信的来源</strong></h2><p>消息 TTL 过期 </p>
<p>队列达到最大长度(队列满了，无法再添加数据到 mq 中) </p>
<p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false. </p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/../images/10-1.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="生产者代码实现"><a href="#生产者代码实现" class="headerlink" title="生产者代码实现"></a>生产者代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANEG=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.19.3&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANEG, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列属性，设置10s的消息过期时间</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">basicProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties();</span><br><span class="line">        basicProperties.builder().expiration(<span class="string">&quot;1&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANEG, <span class="string">&quot;zhangsan&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完毕:&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通、死信队列"><a href="#普通、死信队列" class="headerlink" title="普通、死信队列"></a>普通、死信队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANEG=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE=<span class="string">&quot;noamal_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//与消息队列建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.19.3&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANEG, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接死信队列参数配置</span></span><br><span class="line">        Map&lt;String, Object&gt; argement = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        argement.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        argement.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        argement.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通和死信队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, argement);</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列绑定交换机</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANEG, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="comment">//直接拒绝不重新放回队列</span></span><br><span class="line">            <span class="comment">//channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;普通队列消费者消费消息:&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       channel.basicConsume(NORMAL_QUEUE, <span class="literal">false</span>, deliverCallback1,consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死信队列消费者"><a href="#死信队列消费者" class="headerlink" title="死信队列消费者"></a>死信队列消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//与消息队列建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.19.3&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;死信队列消费者消费消息:&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="literal">false</span>, deliverCallback2, consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息进入死信队列的三种情况"><a href="#消息进入死信队列的三种情况" class="headerlink" title="消息进入死信队列的三种情况"></a>消息进入死信队列的三种情况</h2><h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在消息生产者端设置消息的过期时间,10s后过期未消费则进入死信队列</span></span><br><span class="line"> AMQP.<span class="type">BasicProperties</span> <span class="variable">basicProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties();</span><br><span class="line">        basicProperties.builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br></pre></td></tr></table></figure>

<h3 id="消息被拒绝"><a href="#消息被拒绝" class="headerlink" title="消息被拒绝"></a>消息被拒绝</h3><p>在普通队列的消费者端中直接拒绝消息，消息则会自动进入死信队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="comment">//直接拒绝不重新放回队列</span></span><br><span class="line">            channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;普通队列消费者消费消息:&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       channel.basicConsume(NORMAL_QUEUE, <span class="literal">false</span>, deliverCallback1,consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="队列达到了最大长度"><a href="#队列达到了最大长度" class="headerlink" title="队列达到了最大长度"></a>队列达到了最大长度</h2><p>在普通队列声明时传入参数argement，设置普通队列长度为2，超过两条消息后的消息会写入死信队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接死信队列参数配置</span></span><br><span class="line">        Map&lt;String, Object&gt; argement = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        argement.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        argement.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        argement.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通和死信队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, argement);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列应用及其分类</title>
    <url>/2024/6ca58461.html</url>
    <content><![CDATA[<h1 id="消息队列应用及其分类"><a href="#消息队列应用及其分类" class="headerlink" title="消息队列应用及其分类"></a>消息队列应用及其分类</h1><h2 id="1-什么是MQ"><a href="#1-什么是MQ" class="headerlink" title="1.什么是MQ"></a>1.什么是MQ</h2><p>MQ(message queue)，从字面意思上看，<strong>本质是个队列，FIFO 先入先出</strong>，<strong>只不过队列中存放的内容是message 而已</strong>，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。 <strong>应用于程序之间的一种通信方法，帮助程序之间高效安全的传递消息</strong>。</p>
<h2 id="2-MQ的作用"><a href="#2-MQ的作用" class="headerlink" title="2.MQ的作用"></a>2.MQ的作用</h2><h3 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<h2 id="3-MQ的分类"><a href="#3-MQ的分类" class="headerlink" title="3.MQ的分类"></a>3.MQ的分类</h2><table>
<thead>
<tr>
<th align="center">消息队列</th>
<th align="center">吞吐量</th>
<th align="center">时效性</th>
<th align="center">可用性</th>
<th align="center">可靠性</th>
<th align="center">优势</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">activemq</td>
<td align="center">万级</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">简单易学</td>
<td align="center">中小企业，项目</td>
</tr>
<tr>
<td align="center">rabbitmq</td>
<td align="center">万级</td>
<td align="center"><strong>极高（微秒）</strong></td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">生态好(基本什么语言都支持)<br />时效性高，易学</td>
<td align="center">适用于绝大多数<strong>分布式</strong>应用</td>
</tr>
<tr>
<td align="center">kafka</td>
<td align="center"><strong>十万级</strong></td>
<td align="center">高</td>
<td align="center">极高</td>
<td align="center">高</td>
<td align="center">吞吐量大，可靠性高，强大的数据流处理能力</td>
<td align="center">适用于<strong>大规模的数据处理</strong>场景，比如<strong>日志构建</strong>，数据流传输</td>
</tr>
<tr>
<td align="center">rocketmq</td>
<td align="center">十万级</td>
<td align="center">高</td>
<td align="center">极高</td>
<td align="center">极高</td>
<td align="center">吞吐量大，可扩展性，可靠性</td>
<td align="center">适用于<strong>金融，电商</strong>对<strong>可靠性要求较高</strong>的大规模场景</td>
</tr>
<tr>
<td align="center">pulsar</td>
<td align="center">十万级</td>
<td align="center">高</td>
<td align="center">极高</td>
<td align="center">极高</td>
<td align="center">可用可靠，基于发布订阅模式</td>
<td align="center">适用于大规模分布式系统，实时数据分析</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行时数据区(JAM内存模型)</title>
    <url>/2024/a56b5c26.html</url>
    <content><![CDATA[<h1 id="JVM内存模型-运行时数据区"><a href="#JVM内存模型-运行时数据区" class="headerlink" title="JVM内存模型(运行时数据区)"></a>JVM内存模型(运行时数据区)</h1><p>本篇博客主要介绍JVM的内存模型分为哪些区，以及这些区各自在运行Java程序时起到什么作用。以及不同JDK版本中JVM内存模型有什么变化，其中<strong>方法区和堆</strong>是这篇博客重点介绍的地方。</p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="/../images/11-1.png"></p>
<p>由以上JVM的组成图我们可以知道，JVM内存模型也就是运行时数据区主要由中间(方法区，堆，程序计数器，本地方法栈，Java虚拟机栈)五部分构成其中<strong>方法区和堆是进程所有</strong>，同一进程内的线程共享；<strong>程序计数器，本地方法栈，虚拟机栈每个线程都有一份，互相独立</strong>。以下是五个区域划分图，接下来将逐一详细讲解。</p>
<p><img src="/../images/11-2.png"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>概述：</strong>JVM中的PC寄存器是对物理PC寄存器的一种模拟，作用也与其相同。</p>
<p><strong>作用：</strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。</p>
<p><strong>线程私有：</strong>每个线程都有属于他自己的PC寄存器且线程私有。一是为了记录每个线程正在执行的当前指令地址，二是线程有时会发生阻塞或者中断，当该线程恢复运行时需要知道程序上次运行到哪里结束了，然后从结束点继续运行。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>概述：</strong>每个线程创建时都会创建一个虚拟机栈，其内部保存着一个一个的栈帧，对应一次一次的Java函数调用。</p>
<p><strong>生命周期：</strong>和线程生命周期一样</p>
<p><strong>特点：</strong>方法开始则压栈，结束出栈，先进后出。且不存在垃圾回收。栈溢出会报异常StackOverflow和OOM。栈中存储的都是<strong>栈帧</strong></p>
<p><strong>作用：</strong> <strong>主管Java程序的运行</strong>，其中<strong>栈帧</strong>主要包含<strong>局部变量表、方法返回地址、动态链接、操作数栈</strong>。</p>
<h3 id="栈帧中四部分的作用"><a href="#栈帧中四部分的作用" class="headerlink" title="栈帧中四部分的作用"></a>栈帧中四部分的作用</h3><p><strong>局部变量表：</strong></p>
<p>在方法中声明的变量都记录在局部变量表中，局部变量表中的变量只在当前方法内调用有效，方法结束后随着栈帧的销毁，局部变量表也会销毁。且局部变量表中直接或者间接引用的对象都不会被回收。</p>
<p><strong>操作数栈：</strong></p>
<p>表达式栈。根据字节码指令向操作数栈中压入或者弹出操作数然后进行计算再放回。主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p><strong>动态链接：</strong></p>
<p>每个栈帧内部都包含了一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，<strong>作用就是将符号引用转换为调用方法的直接引用</strong>。</p>
<p><img src="/../images/11-3.png"></p>
<p><strong>方法返回地址：</strong></p>
<p>方法结束后将结果返回的地址。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><strong>概述：</strong>Java虚拟机栈用来管理Java方法的调用，而本地方法栈管理本地方法的调用（本地方法是用C语言实现的），其他方面和Java虚拟机栈并无太大区别</p>
<p><img src="/../images/11-4.png"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>概述：</strong></p>
<ul>
<li><p>创建的对象一般都内存分配都在堆上（逃逸分析，不过大多数JVM都不支持）</p>
</li>
<li><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</p>
</li>
<li><p>堆，是GC(Garbage Collection,垃圾收集器)执行垃圾回收的重点区域。</p>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区</p>
</li>
<li><p>堆内存如果GC后还不够的话会报OOM</p>
</li>
</ul>
<p><strong>堆，栈，方法区之间的关系：</strong></p>
<p>栈管理程序运行，堆管理对象存储。栈上的引用指向堆中该对象的实际存储位置。堆上的对象实例则指向方法区中对象所属类且该对象的方法实现也保存在方法区中。</p>
<p><img src="/../images/11-5.png"></p>
<p><strong>JDK7和JDK8堆空间逻辑划分：</strong></p>
<p>JDK7：堆空间被划分为新生代+老年代+永久代（永久代属于方法区，所以是逻辑划分）</p>
<p>JDK8：堆空间被划分为新生代+老年代+元空间（元空间其实就是方法区的&#x3D;换个名字，不过相比还是有点区别，后面会讲）</p>
<p><img src="/../images/11-7.png"></p>
<p><img src="/../images/11-6.png"></p>
<h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在JVM中的对象可以分为两类</p>
<p>存储在M中的Java对象可以被划分为两类：</p>
<blockquote>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<br>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p>
</blockquote>
<p>JVM的堆区细分的话可以分为年轻代和老年代，而年轻代又可以分为Eden，Survivor0，Survivor1区。且一般老年代和新生代在堆中占比为2:1，eden和s0，s1一般为8:1:1。</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li><p>当伊甸园的空间填满时，程序又需要创建对象，M的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区。</p>
</li>
<li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li><p>那时候能去养老区呢？可以设置次数。默认是15次。</p>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC:Major GC,进行养老区的内存清理。</p>
</li>
<li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</p>
</li>
</ol>
<p><img src="/../images/11-8.png"></p>
<p><img src="/../images/11-9.png"></p>
<p><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集（后面讲原因）。</strong></p>
<h3 id="Minor-GC，Major-GC，Full-GC"><a href="#Minor-GC，Major-GC，Full-GC" class="headerlink" title="Minor GC，Major GC，Full GC"></a>Minor GC，Major GC，Full GC</h3><p>JVM进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。<br>针对HotSpot JVM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC),一种是整堆收集(Full GC)</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集(Minor GC&#x2F;Young GC):只是新生代的垃圾收集</li>
<li>老年代收集(Major GC&#x2F;old GC):只是老年代的垃圾收集。</li>
</ul>
<p>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。</p>
<p><strong>Minor GC（年轻代GC）触发条件:</strong></p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC,这里的年轻代满指的是Eden代满，Survivor满不会引发GC。(每次Minor GC会清理年轻<br>代的内存。)</li>
<li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><strong>Major GC(老年代GC)触发条件：</strong></p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
<li>Major GC的速度一般会比Minor GC慢倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
<p><strong>Full GC(全堆)触发条件：</strong></p>
<ul>
<li>调用System.gc()时，系统建议执行Full GC,但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
</ul>
<h3 id="为什么要进行分代？不分代不行吗？"><a href="#为什么要进行分代？不分代不行吗？" class="headerlink" title="为什么要进行分代？不分代不行吗？"></a>为什么要进行分代？不分代不行吗？</h3><p>其实，我们程序中大部分的对象都是临时对象。也就是一次性的，经过一次GC就会被回收。其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。<strong>如果没有分代，那所有的对象都在一块</strong>，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会<strong>对堆的所有区域进行扫描</strong>。而很多对象都是朝生夕死的，<strong>如果分代的话</strong>，把新创建的对象放到某一地方，当GC的时候先把这块<strong>存储“朝生夕死”对象的区域进行回收</strong>，这样就会腾出<strong>很大的空间出来，且性能高</strong>。</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol>
<li>优先分配到Eden区</li>
<li>大对象直接分配到老年代</li>
<li>长期存活的对象直接分配到老年代</li>
</ol>
<p><strong>为什么大对象直接分配到老年代：</strong></p>
<ul>
<li>老年代与年轻代在堆中内存占比为2:1，老年代更适合放大对象</li>
<li>年轻代如果存放大对象容易产生内存碎片</li>
<li>年轻代存放大对象容易导致年轻代内存长期处于较满的状态，可能频繁触发GC</li>
</ul>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>将堆上的对象分配到栈上，减少堆的压力。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> my <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line"><span class="comment">// use v</span></span><br><span class="line">v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象只在方法中使用，并没有在方法外被引用，所以理论上可以发生逃逸。</p>
<p><strong>但逃逸分析技术并不成熟：</strong></p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。所以大多数JVM都不采用逃逸分析技术。所以前面的结论还是适用的即<strong>对象实例都是分配在堆上</strong>。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>栈，堆，方法区之间的交互关系：</strong></p>
<p><img src="/../images/11-10.png"></p>
<p><strong>JDK6以前，JDK7和JDK8方法区的变动：</strong></p>
<p><strong>注意1.8之后元空间的数据保存在本地内存中</strong></p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20240516213114817.png" alt="image-20240516213114817"></p>
<p><img src="/../images/11-13.png"></p>
<p><img src="/../images/11-14.png"></p>
<p><img src="/../images/11-15.png"></p>
<p><strong>为什么要将字符串常量池设置到堆中？</strong></p>
<p>方法区几乎不进行GC，而我们程序使用的字符串大多数都是一次性的临时的，如果将字符串常量池设置在方法区中，程序结束时方法区内可能保留了很多没用的字符串，而由于方法区很少GC，所以这些字符串就一直积累，占据方法区内存空间。</p>
<p><strong>永久代为什么被元空间替换？</strong></p>
<p>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的ooM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>对永久代调优比较困难。</p>
<p><strong>方法区存储什么？</strong></p>
<p>方法区主要存储一些静态变量，类信息，方法信息等</p>
<h3 id="常量池-运行时常量池"><a href="#常量池-运行时常量池" class="headerlink" title="常量池&amp;运行时常量池"></a>常量池&amp;运行时常量池</h3><p><img src="/../images/11-12.png"></p>
<p><strong>两者区别与联系：</strong></p>
<p>Java字节码文件中的类信息，字段，方法，字符串等一些信息保存在字节码文件的常量池中。常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<p>而运行时常量池是方法区的一部分，常量池表(Constant Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。也就是说字节码文件加载到JVM后，字节码文件中的常量池里面保存的信息就到了运行时常量池中。</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用。</strong><br>字面量比较接近]ava语言层次的常量概念，如文本字符串、被声明为final的常量值等。</p>
<p>而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p><strong>只要常量池中的变量没有被任何地方引用，就可以被回收。</strong></p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是]ava堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器己经被回收</li>
<li>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="对象实例化及内存分布"><a href="#对象实例化及内存分布" class="headerlink" title="对象实例化及内存分布"></a>对象实例化及内存分布</h2><p><strong>对象实例化：</strong></p>
<p><img src="/../images/11-17.png"></p>
<p><strong>对象内存布局：</strong></p>
<p><img src="/../images/11-18.png"></p>
<p><strong>对象访问定位：</strong></p>
<p><img src="/../images/11-20.png"></p>
<p><img src="/../images/11-21.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../images/11-16.png"></p>
<p><img src="/../images/11-19.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
