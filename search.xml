<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MVCC机制及其原理</title>
    <url>/2023/55c34784.html</url>
    <content><![CDATA[<p>helllo！大家好，今天主要给大家分享一篇有关MySQL中可重复读隔离级别的实现原理，废话不多说，我们直接进入正题！</p>
<h1 id="四大隔离级别与MVCC机制"><a href="#四大隔离级别与MVCC机制" class="headerlink" title="四大隔离级别与MVCC机制"></a>四大隔离级别与MVCC机制</h1><p>在介绍可重复读的实现原理之前我们有必要先来了解一下四大隔离级别与MVCC机制的实现原理</p>
<h2 id="一-四大隔离级别"><a href="#一-四大隔离级别" class="headerlink" title="一.四大隔离级别"></a>一.四大隔离级别</h2><ul>
<li><font color="red">READ UNCOMMITTED</font>:读未提交，在该隔离级别下，所有事务都可以看到其他事务未提交的数据。不能避免脏读，不可重复读和幻读。</li>
<li><font color="red">READ COMMITTED</font>:读已提交，在该隔离级别下，一个事务只能看见其他事务已经提交的改变。可以避免脏读，但是依然存在不可重复读和幻读问题。</li>
<li><font color="red">REPEATABLE READ</font>:可重复读，当一个事务正在读取数据时，其他事务对该数据的修改对当前事务是不可见的。解决了不可重复读，也是MySQL的默认隔离级别，但依旧存在幻读问题。</li>
<li><font color="red">SERIALIZABLE</font>:可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读</li>
</ul>
<h2 id="二-MVCC"><a href="#二-MVCC" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><h3 id="什么是MVCC机制呢？"><a href="#什么是MVCC机制呢？" class="headerlink" title="什么是MVCC机制呢？"></a>什么是MVCC机制呢？</h3><p>MVCC （Multiversion Concurrency Control），即多版本并发控制。顾名思义，是通过数据行的多个版本管理来实现数据库的并发控制。讲人话就是，每个事务都是在对数据行不同的版本进行操作，实现了数据一致性读的。</p>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><h4 id="1-隐藏字段和Undo-Log版本链"><a href="#1-隐藏字段和Undo-Log版本链" class="headerlink" title="1.隐藏字段和Undo Log版本链"></a>1.隐藏字段和Undo Log版本链</h4><p>对InnoDB数据存储结构了解的朋友来说，想必对于trx_id和roll-pointer这两条隐藏列应该不陌生，这里再做一下解释</p>
<ul>
<li><p><strong>trx-id</strong>:每次对某一条聚簇索引改动时都会把该事务的id赋值给trx_id</p>
</li>
<li><p><strong>roll-pointer</strong>:每次对聚簇索引进行改变时，都会把旧版本写入undo日志中，而roll_pointer类似一个指针指向修改之前的那个旧版本，这样就可以通过该隐藏列修改之前的数据</p>
<p><img src="/../images/1-1.png"></p>
<p><strong>假如有两条id分别为10，20的事务对该条数据进行update操作</strong></p>
<table>
<thead>
<tr>
<th align="left">顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td align="left">2</td>
<td></td>
<td>begin</td>
</tr>
<tr>
<td align="left">3</td>
<td>update set name&#x3D;”李四” where id &#x3D;1;</td>
<td></td>
</tr>
<tr>
<td align="left">4</td>
<td>update set name&#x3D;”王五” where id &#x3D;1;</td>
<td></td>
</tr>
<tr>
<td align="left">5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td align="left">6</td>
<td></td>
<td>update set name&#x3D;”钱七” where id &#x3D;1;</td>
</tr>
<tr>
<td align="left">7</td>
<td></td>
<td>update set name&#x3D;”宋八” where id &#x3D;1;</td>
</tr>
<tr>
<td align="left">8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<hr>
</li>
</ul>
<p><strong><font color="brown">其对应的undolog版本链如下：</font></strong></p>
<p><img src="/../images/1-2.png"></p>
<h4 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2.ReadView"></a>2.ReadView</h4><h6 id="2-1-什么是ReadView？为什么要引入ReadView？"><a href="#2-1-什么是ReadView？为什么要引入ReadView？" class="headerlink" title="2.1 什么是ReadView？为什么要引入ReadView？"></a>2.1 什么是ReadView？为什么要引入ReadView？</h6><p>ReadView其实就是一个事务开启时对某条记录进行操作时生成的版本快照。</p>
<ul>
<li>使用 READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</li>
<li>使用 SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</li>
<li>使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。</li>
</ul>
<p><strong>核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</strong></p>
<h6 id="2-2-ReadView的主要组成部分"><a href="#2-2-ReadView的主要组成部分" class="headerlink" title="2.2 ReadView的主要组成部分"></a>2.2 ReadView的主要组成部分</h6><ul>
<li><strong>creator-trx-id</strong>:创建这个 Read View 的事务 ID。</li>
<li><strong>trx-ids</strong>:表示当前系统中活跃的事务的id列表</li>
<li><strong>min-trx-id</strong>:表示当前活跃事务列表中最小的事务id</li>
<li><strong>max-trx-id</strong>:表示生成ReadView时系统中应该分配给下一个事务的 id 值（这里需要注意的是，max-trx-id是指的系统中的最大事务id之后应该分配的id，有别于最大活跃事务id）</li>
</ul>
<h5 id="2-3-ReadView的应用规则"><a href="#2-3-ReadView的应用规则" class="headerlink" title="2.3 ReadView的应用规则"></a>2.3 ReadView的应用规则</h5><p>有了这个ReadView就可以根据以下规则判断当前版本信息是否可见</p>
<ul>
<li><p>如果当前被访问版本的trx_id与当前ReadView的creator-trx-id相同，那就意味着当前事务正在访问它之前修改过的数据，所以该版本的数据对于当前事务来说是可见的</p>
</li>
<li><p>如果当前被访问版本的trx_id小于ReadView中的min-trx-id:，那就意味着生成该ReadView版本的事务在当前版本生成ReadView之前就已经提交了，所以该条记录对于当前事务来说是可见的</p>
</li>
<li><p>如果当前被访问版本的trx_id大于或等于max-trx-id:，那就意味着生成该版本的事务是在当前版本生成ReadView之后才开启的，所以版本数据对于当前事务来说是不可见的</p>
</li>
<li><p>如果当前被访问版本的ReadView的trx_id在min-trx-id和max-trx-id之间的话，那就要判断一下trx_id在不在trx_ids列表中，此时存在两种情况</p>
<p><em><strong>第一种情况：</strong></em> ReadView的trx_id<strong>在</strong>min-trx-id和max-trx-id之间，那么生成该版本的事务还未提交，因此，对于当前事务来说该版本的记录是不可见的 </p>
<p><em><strong>第二种情况：</strong></em> ReadView的trx_id<strong>不在</strong>min-trx-id和max-trx-id之间，那么就意味着生成该ReadView版本的事务已经提交，该版本的记录对于当前事务来说是可见的</p>
</li>
</ul>
<h5 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h5><p>不知道看到这里的朋友有没有思考过这样一个问题，如下：<br>现在有两个活跃的事务A,B他们的id分别是10和20，当A查询了某条记录后，B对该记录做了修改，并且B提交了事务，<br>此时，该记录的ReadView的trx_id应该为20，此时A事务再去对该记录进行查询操作，这时候A会发现这条记录的ReadView为20既比自己的10大，又比max_trx_id（21）小，且不在trx_ids里面，根据上面提到的ReadView应用规则，A事务是可以去读取这条记录的，那这不违反了可重复读的隔离机制了吗？别急，接下来我们就来讲讲MVCC机制是如何来实现隔离级别的。</p>
<h2 id="三-MVCC机制如何保证隔离级别的实现"><a href="#三-MVCC机制如何保证隔离级别的实现" class="headerlink" title="三.MVCC机制如何保证隔离级别的实现"></a>三.MVCC机制如何保证隔离级别的实现</h2><p>想必能看到这里的朋友们对MVCC的原理已经有了基本的了解，那么接下来我们就来看看MVCC机制如何保证隔离级别的实现，由于READ UNCOMMITTED 隔离级别的事务是当前读，SERIALIZABLE 隔离级别的事务是基于锁实现的，所以，我们在这里主要讨论<strong>读已提交和可重复读</strong>。</p>
<h3 id="3-1-MVCC的整体操作流程"><a href="#3-1-MVCC的整体操作流程" class="headerlink" title="3.1 MVCC的整体操作流程"></a>3.1 MVCC的整体操作流程</h3><ol>
<li>首先获取事务自己的版本号，也就是事务id</li>
<li>然后获取ReadView</li>
<li>将自己的事务id与ReadView的trx_id进行比较</li>
<li>如果不符合ReadView的规则，那么就从Undo Log中获取历史快照</li>
<li>最后返回符合规则的数据</li>
</ol>
<h3 id="3-2-在隔离级别为读已提交时"><a href="#3-2-在隔离级别为读已提交时" class="headerlink" title="3.2 在隔离级别为读已提交时"></a>3.2 在隔离级别为读已提交时</h3><p>在隔离级别为读已提交时，每一次执行select语句，每次都会重新获取一次最新的ReadView</p>
<table>
<thead>
<tr>
<th align="center">事务</th>
<th align="center">ReadView获取情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &#x3D;1;</td>
<td align="center">获取一次ReanView</td>
</tr>
<tr>
<td align="center">…….</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &#x3D;1;</td>
<td align="center">获取一次ReanView</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3-3-在隔离级别为可重复读时"><a href="#3-3-在隔离级别为可重复读时" class="headerlink" title="3.3 在隔离级别为可重复读时"></a>3.3 在隔离级别为可重复读时</h3><p>在隔离级别为可重复读时，事务开启后只有在第一次select语句后才会获取ReadView，之后的select都是沿用这个ReadView，并不会再去获取新的ReadView</p>
<p><img src="/../images/1-3.png"></p>
<h3 id="3-4-解释2-4思考题"><a href="#3-4-解释2-4思考题" class="headerlink" title="3.4 解释2.4思考题"></a>3.4 解释2.4思考题</h3><p>从以上在两种不同隔离机制下对MVCC的讲解不难看出，由于使用的隔离级别是可重复读的隔离级别，因此，从A事务开始并第一次执行select语句时，就产生了一个ReanView，此后A事务对该条数据进行的查询语句都是基于该版本的记录进行查询，因此B事务对该条数据的操作对A来说是不可见的。</p>
<h3 id="3-5-如何解决幻读"><a href="#3-5-如何解决幻读" class="headerlink" title="3.5 如何解决幻读"></a>3.5 如何解决幻读</h3><p>假设现在student表中有如下所示的一条数据：</p>
<table>
<thead>
<tr>
<th>trx_id&#x3D;10</th>
<th>数据<br />id&#x3D;1,name&#x3D;”张三”，age&#x3D;18</th>
<th>roll_pointer&#x3D;null</th>
</tr>
</thead>
</table>
<p>现有两个事务A，B，他们的id分别是20和30</p>
<p><strong>步骤一：</strong>事务A首先执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;=1; </span><br></pre></td></tr></table></figure>

<p>在开始查询前ReadView的情况如下：trx_ids&#x3D;[20,30]，min_trx_id&#x3D;20 , max_trx_id&#x3D;31 , creator_trx_id&#x3D;20。由于<strong>trx_id&lt;min_tex_id</strong>,所以该条数据对于事务A可见</p>
<p><strong>步骤二：</strong>事务B往表中插入两条数据，并提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(id,name,age) values(2,&#x27;李四&#x27;,12);</span><br><span class="line">insert into student(id,name,age) values(3,&#x27;王五&#x27;,16); </span><br></pre></td></tr></table></figure>

<p><strong>步骤三：</strong>接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p><strong><font  color="red">分析如下</font></strong>:</p>
<ul>
<li><p>对于id&#x3D;1的记录，由于第一次和第二次查询使用的是同一个ReadView，所以该条数据能够被查询出来</p>
</li>
<li><p>对于id&#x3D;2和id&#x3D;3的记录，其实无论B事务提不提交对于A来说B的操作都是不可见的，理由如下：</p>
</li>
<li><p>如果B没有提交事务那么根据上面ReadView使用规则的第四条可以判断B事务新增的记录不可见</p>
</li>
<li><p>如果B提交了事务，此时trx_ids&#x3D;[20]，min_trx_id&#x3D;20，那么根据上面ReadView使用规则的第三条也可以判断这两条记录对于A来说不可见</p>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要讲解了一下几点：</p>
<ul>
<li><a href="#%E4%B8%80.%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">四大隔离级别</a></li>
<li><a href="#%E4%BA%8C.MVCC">MVCC机制及其实现原理</a></li>
<li><a href="#%E4%B8%89.MVCC%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0">MVCC机制如何保证读已提交和可重复读的实现</a></li>
<li>[ReadView的应用规则](#2.3 ReadView的应用规则)</li>
<li>[MVCC如何解决幻读](#3.5 如何解决幻读)</li>
</ul>
<p>希望这篇文章能够让你对MVCC有更好的了解<img src="https://dl4.weshineapp.com/gif/20170714/776d24c1ce2b76a37367b886699a25f0.gif?f=micro_5byA5b+D" alt="img"></p>
]]></content>
      <tags>
        <tag>MySQL技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
